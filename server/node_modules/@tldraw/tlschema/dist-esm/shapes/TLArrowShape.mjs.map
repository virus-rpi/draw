{
  "version": 3,
  "sources": ["../../src/shapes/TLArrowShape.ts"],
  "sourcesContent": ["import { createMigrationSequence } from '@tldraw/store'\nimport { T } from '@tldraw/validate'\nimport { TLRichText, richTextValidator, toRichText } from '../misc/TLRichText'\nimport { VecModel, vecModelValidator } from '../misc/geometry-types'\nimport { createBindingId } from '../records/TLBinding'\nimport { TLShapeId, createShapePropsMigrationIds } from '../records/TLShape'\nimport { RecordProps, TLPropsMigration, createPropsMigration } from '../recordsWithProps'\nimport { StyleProp } from '../styles/StyleProp'\nimport {\n\tDefaultColorStyle,\n\tDefaultLabelColorStyle,\n\tTLDefaultColorStyle,\n} from '../styles/TLColorStyle'\nimport { DefaultDashStyle, TLDefaultDashStyle } from '../styles/TLDashStyle'\nimport { DefaultFillStyle, TLDefaultFillStyle } from '../styles/TLFillStyle'\nimport { DefaultFontStyle, TLDefaultFontStyle } from '../styles/TLFontStyle'\nimport { DefaultSizeStyle, TLDefaultSizeStyle } from '../styles/TLSizeStyle'\nimport { TLBaseShape } from './TLBaseShape'\n\nconst arrowKinds = ['arc', 'elbow'] as const\n/**\n * Style property for arrow shape kind, determining how the arrow is drawn.\n *\n * Arrows can be drawn as arcs (curved) or elbows (angled with straight segments).\n * This affects the visual appearance and behavior of arrow shapes.\n *\n * @example\n * ```ts\n * // Create an arrow with arc style (curved)\n * const arcArrow: TLArrowShape = {\n *   // ... other properties\n *   props: {\n *     kind: 'arc',\n *     // ... other props\n *   }\n * }\n *\n * // Create an arrow with elbow style (angled)\n * const elbowArrow: TLArrowShape = {\n *   // ... other properties\n *   props: {\n *     kind: 'elbow',\n *     // ... other props\n *   }\n * }\n * ```\n *\n * @public\n */\nexport const ArrowShapeKindStyle = StyleProp.defineEnum('tldraw:arrowKind', {\n\tdefaultValue: 'arc',\n\tvalues: arrowKinds,\n})\n\n/**\n * The type representing arrow shape kinds.\n *\n * @public\n */\nexport type TLArrowShapeKind = T.TypeOf<typeof ArrowShapeKindStyle>\n\nconst arrowheadTypes = [\n\t'arrow',\n\t'triangle',\n\t'square',\n\t'dot',\n\t'pipe',\n\t'diamond',\n\t'inverted',\n\t'bar',\n\t'none',\n] as const\n\n/**\n * Style property for the arrowhead at the start of an arrow.\n *\n * Defines the visual style of the arrowhead at the beginning of the arrow path.\n * Can be one of several predefined styles or none for no arrowhead.\n *\n * @example\n * ```ts\n * // Arrow with no start arrowhead but triangle end arrowhead\n * const arrow: TLArrowShape = {\n *   // ... other properties\n *   props: {\n *     arrowheadStart: 'none',\n *     arrowheadEnd: 'triangle',\n *     // ... other props\n *   }\n * }\n * ```\n *\n * @public\n */\nexport const ArrowShapeArrowheadStartStyle = StyleProp.defineEnum('tldraw:arrowheadStart', {\n\tdefaultValue: 'none',\n\tvalues: arrowheadTypes,\n})\n\n/**\n * Style property for the arrowhead at the end of an arrow.\n *\n * Defines the visual style of the arrowhead at the end of the arrow path.\n * Defaults to 'arrow' style, giving arrows their characteristic pointed appearance.\n *\n * @example\n * ```ts\n * // Arrow with different start and end arrowheads\n * const doubleArrow: TLArrowShape = {\n *   // ... other properties\n *   props: {\n *     arrowheadStart: 'triangle',\n *     arrowheadEnd: 'diamond',\n *     // ... other props\n *   }\n * }\n * ```\n *\n * @public\n */\nexport const ArrowShapeArrowheadEndStyle = StyleProp.defineEnum('tldraw:arrowheadEnd', {\n\tdefaultValue: 'arrow',\n\tvalues: arrowheadTypes,\n})\n\n/**\n * The type representing arrowhead styles for both start and end of arrows.\n *\n * @public\n */\nexport type TLArrowShapeArrowheadStyle = T.TypeOf<typeof ArrowShapeArrowheadStartStyle>\n\n/**\n * Properties specific to arrow shapes.\n *\n * Defines all the configurable aspects of an arrow shape, including visual styling,\n * geometry, text labeling, and positioning. Arrows can connect two points and\n * optionally display text labels.\n *\n * @example\n * ```ts\n * const arrowProps: TLArrowShapeProps = {\n *   kind: 'arc',\n *   labelColor: 'black',\n *   color: 'blue',\n *   fill: 'none',\n *   dash: 'solid',\n *   size: 'm',\n *   arrowheadStart: 'none',\n *   arrowheadEnd: 'arrow',\n *   font: 'draw',\n *   start: { x: 0, y: 0 },\n *   end: { x: 100, y: 100 },\n *   bend: 0.2,\n *   richText: toRichText('Label'),\n *   labelPosition: 0.5,\n *   scale: 1,\n *   elbowMidPoint: 0.5\n * }\n * ```\n *\n * @public\n */\nexport interface TLArrowShapeProps {\n\tkind: TLArrowShapeKind\n\tlabelColor: TLDefaultColorStyle\n\tcolor: TLDefaultColorStyle\n\tfill: TLDefaultFillStyle\n\tdash: TLDefaultDashStyle\n\tsize: TLDefaultSizeStyle\n\tarrowheadStart: TLArrowShapeArrowheadStyle\n\tarrowheadEnd: TLArrowShapeArrowheadStyle\n\tfont: TLDefaultFontStyle\n\tstart: VecModel\n\tend: VecModel\n\tbend: number\n\trichText: TLRichText\n\tlabelPosition: number\n\tscale: number\n\telbowMidPoint: number\n}\n\n/**\n * A complete arrow shape record.\n *\n * Combines the base shape interface with arrow-specific properties to create\n * a full arrow shape that can be stored and manipulated in the editor.\n *\n * @example\n * ```ts\n * const arrowShape: TLArrowShape = {\n *   id: 'shape:arrow123',\n *   typeName: 'shape',\n *   type: 'arrow',\n *   x: 100,\n *   y: 200,\n *   rotation: 0,\n *   index: 'a1',\n *   parentId: 'page:main',\n *   isLocked: false,\n *   opacity: 1,\n *   props: {\n *     kind: 'arc',\n *     start: { x: 0, y: 0 },\n *     end: { x: 150, y: 100 },\n *     // ... other props\n *   },\n *   meta: {}\n * }\n * ```\n *\n * @public\n */\nexport type TLArrowShape = TLBaseShape<'arrow', TLArrowShapeProps>\n\n/**\n * Validation configuration for arrow shape properties.\n *\n * Defines the validators for each property of an arrow shape, ensuring that\n * arrow shape data is valid and conforms to the expected types and constraints.\n *\n * @example\n * ```ts\n * // The validators ensure proper typing and validation\n * const validator = T.object(arrowShapeProps)\n * const validArrowProps = validator.validate({\n *   kind: 'arc',\n *   start: { x: 0, y: 0 },\n *   end: { x: 100, y: 50 },\n *   // ... other required properties\n * })\n * ```\n *\n * @public\n */\nexport const arrowShapeProps: RecordProps<TLArrowShape> = {\n\tkind: ArrowShapeKindStyle,\n\tlabelColor: DefaultLabelColorStyle,\n\tcolor: DefaultColorStyle,\n\tfill: DefaultFillStyle,\n\tdash: DefaultDashStyle,\n\tsize: DefaultSizeStyle,\n\tarrowheadStart: ArrowShapeArrowheadStartStyle,\n\tarrowheadEnd: ArrowShapeArrowheadEndStyle,\n\tfont: DefaultFontStyle,\n\tstart: vecModelValidator,\n\tend: vecModelValidator,\n\tbend: T.number,\n\trichText: richTextValidator,\n\tlabelPosition: T.number,\n\tscale: T.nonZeroNumber,\n\telbowMidPoint: T.number,\n}\n\n/**\n * Migration version identifiers for arrow shape properties.\n *\n * These track the evolution of the arrow shape schema over time, with each\n * version representing a specific change to the arrow shape structure or properties.\n *\n * @example\n * ```ts\n * // Used internally for migration system\n * if (version < arrowShapeVersions.AddLabelColor) {\n *   // Apply label color migration\n * }\n * ```\n *\n * @public\n */\nexport const arrowShapeVersions = createShapePropsMigrationIds('arrow', {\n\tAddLabelColor: 1,\n\tAddIsPrecise: 2,\n\tAddLabelPosition: 3,\n\tExtractBindings: 4,\n\tAddScale: 5,\n\tAddElbow: 6,\n\tAddRichText: 7,\n})\n\nfunction propsMigration(migration: TLPropsMigration) {\n\treturn createPropsMigration<TLArrowShape>('shape', 'arrow', migration)\n}\n\n/**\n * Complete migration sequence for arrow shapes.\n *\n * Defines all the migrations needed to transform arrow shape data from older\n * versions to the current version. Each migration handles a specific schema change,\n * ensuring backward compatibility and smooth data evolution.\n *\n * @public\n */\nexport const arrowShapeMigrations = createMigrationSequence({\n\tsequenceId: 'com.tldraw.shape.arrow',\n\tretroactive: false,\n\tsequence: [\n\t\tpropsMigration({\n\t\t\tid: arrowShapeVersions.AddLabelColor,\n\t\t\tup: (props) => {\n\t\t\t\tprops.labelColor = 'black'\n\t\t\t},\n\t\t\tdown: 'retired',\n\t\t}),\n\n\t\tpropsMigration({\n\t\t\tid: arrowShapeVersions.AddIsPrecise,\n\t\t\tup: ({ start, end }) => {\n\t\t\t\tif (start.type === 'binding') {\n\t\t\t\t\tstart.isPrecise = !(start.normalizedAnchor.x === 0.5 && start.normalizedAnchor.y === 0.5)\n\t\t\t\t}\n\t\t\t\tif (end.type === 'binding') {\n\t\t\t\t\tend.isPrecise = !(end.normalizedAnchor.x === 0.5 && end.normalizedAnchor.y === 0.5)\n\t\t\t\t}\n\t\t\t},\n\t\t\tdown: ({ start, end }) => {\n\t\t\t\tif (start.type === 'binding') {\n\t\t\t\t\tif (!start.isPrecise) {\n\t\t\t\t\t\tstart.normalizedAnchor = { x: 0.5, y: 0.5 }\n\t\t\t\t\t}\n\t\t\t\t\tdelete start.isPrecise\n\t\t\t\t}\n\t\t\t\tif (end.type === 'binding') {\n\t\t\t\t\tif (!end.isPrecise) {\n\t\t\t\t\t\tend.normalizedAnchor = { x: 0.5, y: 0.5 }\n\t\t\t\t\t}\n\t\t\t\t\tdelete end.isPrecise\n\t\t\t\t}\n\t\t\t},\n\t\t}),\n\n\t\tpropsMigration({\n\t\t\tid: arrowShapeVersions.AddLabelPosition,\n\t\t\tup: (props) => {\n\t\t\t\tprops.labelPosition = 0.5\n\t\t\t},\n\t\t\tdown: (props) => {\n\t\t\t\tdelete props.labelPosition\n\t\t\t},\n\t\t}),\n\n\t\t{\n\t\t\tid: arrowShapeVersions.ExtractBindings,\n\t\t\tscope: 'store',\n\t\t\tup: (oldStore) => {\n\t\t\t\ttype OldArrowTerminal =\n\t\t\t\t\t| {\n\t\t\t\t\t\t\ttype: 'point'\n\t\t\t\t\t\t\tx: number\n\t\t\t\t\t\t\ty: number\n\t\t\t\t\t  }\n\t\t\t\t\t| {\n\t\t\t\t\t\t\ttype: 'binding'\n\t\t\t\t\t\t\tboundShapeId: TLShapeId\n\t\t\t\t\t\t\tnormalizedAnchor: VecModel\n\t\t\t\t\t\t\tisExact: boolean\n\t\t\t\t\t\t\tisPrecise: boolean\n\t\t\t\t\t  }\n\t\t\t\t\t// new type:\n\t\t\t\t\t| { type?: undefined; x: number; y: number }\n\n\t\t\t\ttype OldArrow = TLBaseShape<'arrow', { start: OldArrowTerminal; end: OldArrowTerminal }>\n\n\t\t\t\tconst arrows = Object.values(oldStore).filter(\n\t\t\t\t\t(r: any): r is OldArrow => r.typeName === 'shape' && r.type === 'arrow'\n\t\t\t\t)\n\n\t\t\t\tfor (const arrow of arrows) {\n\t\t\t\t\tconst { start, end } = arrow.props\n\t\t\t\t\tif (start.type === 'binding') {\n\t\t\t\t\t\tconst id = createBindingId()\n\t\t\t\t\t\tconst binding = {\n\t\t\t\t\t\t\ttypeName: 'binding',\n\t\t\t\t\t\t\tid,\n\t\t\t\t\t\t\ttype: 'arrow',\n\t\t\t\t\t\t\tfromId: arrow.id,\n\t\t\t\t\t\t\ttoId: start.boundShapeId,\n\t\t\t\t\t\t\tmeta: {},\n\t\t\t\t\t\t\tprops: {\n\t\t\t\t\t\t\t\tterminal: 'start',\n\t\t\t\t\t\t\t\tnormalizedAnchor: start.normalizedAnchor,\n\t\t\t\t\t\t\t\tisExact: start.isExact,\n\t\t\t\t\t\t\t\tisPrecise: start.isPrecise,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\toldStore[id] = binding\n\t\t\t\t\t\tarrow.props.start = { x: 0, y: 0 }\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdelete arrow.props.start.type\n\t\t\t\t\t}\n\t\t\t\t\tif (end.type === 'binding') {\n\t\t\t\t\t\tconst id = createBindingId()\n\t\t\t\t\t\tconst binding = {\n\t\t\t\t\t\t\ttypeName: 'binding',\n\t\t\t\t\t\t\tid,\n\t\t\t\t\t\t\ttype: 'arrow',\n\t\t\t\t\t\t\tfromId: arrow.id,\n\t\t\t\t\t\t\ttoId: end.boundShapeId,\n\t\t\t\t\t\t\tmeta: {},\n\t\t\t\t\t\t\tprops: {\n\t\t\t\t\t\t\t\tterminal: 'end',\n\t\t\t\t\t\t\t\tnormalizedAnchor: end.normalizedAnchor,\n\t\t\t\t\t\t\t\tisExact: end.isExact,\n\t\t\t\t\t\t\t\tisPrecise: end.isPrecise,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\toldStore[id] = binding\n\t\t\t\t\t\tarrow.props.end = { x: 0, y: 0 }\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdelete arrow.props.end.type\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\tpropsMigration({\n\t\t\tid: arrowShapeVersions.AddScale,\n\t\t\tup: (props) => {\n\t\t\t\tprops.scale = 1\n\t\t\t},\n\t\t\tdown: (props) => {\n\t\t\t\tdelete props.scale\n\t\t\t},\n\t\t}),\n\t\tpropsMigration({\n\t\t\tid: arrowShapeVersions.AddElbow,\n\t\t\tup: (props) => {\n\t\t\t\tprops.kind = 'arc'\n\t\t\t\tprops.elbowMidPoint = 0.5\n\t\t\t},\n\t\t\tdown: (props) => {\n\t\t\t\tdelete props.kind\n\t\t\t\tdelete props.elbowMidPoint\n\t\t\t},\n\t\t}),\n\t\tpropsMigration({\n\t\t\tid: arrowShapeVersions.AddRichText,\n\t\t\tup: (props) => {\n\t\t\t\tprops.richText = toRichText(props.text)\n\t\t\t\tdelete props.text\n\t\t\t},\n\t\t\t// N.B. Explicitly no down state so that we force clients to update.\n\t\t\t// down: (props) => {\n\t\t\t// \tdelete props.richText\n\t\t\t// },\n\t\t}),\n\t],\n})\n"],
  "mappings": "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",
  "names": []
}
