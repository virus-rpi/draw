{
  "version": 3,
  "sources": ["../../src/lib/ImmutableMap.ts"],
  "sourcesContent": ["/*!\n * This file was lovingly and delicately extracted from Immutable.js\n * MIT License: https://github.com/immutable-js/immutable-js/blob/main/LICENSE\n * Copyright (c) 2014-present, Lee Byron and other contributors.\n */\n\nfunction smi(i32: number) {\n\treturn ((i32 >>> 1) & 0x40000000) | (i32 & 0xbfffffff)\n}\n\nconst defaultValueOf = Object.prototype.valueOf\n\nfunction hash(o: any) {\n\tif (o == null) {\n\t\treturn hashNullish(o)\n\t}\n\n\tif (typeof o.hashCode === 'function') {\n\t\t// Drop any high bits from accidentally long hash codes.\n\t\treturn smi(o.hashCode(o))\n\t}\n\n\tconst v = valueOf(o)\n\n\tif (v == null) {\n\t\treturn hashNullish(v)\n\t}\n\n\tswitch (typeof v) {\n\t\tcase 'boolean':\n\t\t\t// The hash values for built-in constants are a 1 value for each 5-byte\n\t\t\t// shift region expect for the first, which encodes the value. This\n\t\t\t// reduces the odds of a hash collision for these common values.\n\t\t\treturn v ? 0x42108421 : 0x42108420\n\t\tcase 'number':\n\t\t\treturn hashNumber(v)\n\t\tcase 'string':\n\t\t\treturn v.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(v) : hashString(v)\n\t\tcase 'object':\n\t\tcase 'function':\n\t\t\treturn hashJSObj(v)\n\t\tcase 'symbol':\n\t\t\treturn hashSymbol(v)\n\t\tdefault:\n\t\t\tif (typeof v.toString === 'function') {\n\t\t\t\treturn hashString(v.toString())\n\t\t\t}\n\t\t\tthrow new Error('Value type ' + typeof v + ' cannot be hashed.')\n\t}\n}\n\nfunction hashNullish(nullish: null | undefined) {\n\treturn nullish === null ? 0x42108422 : /* undefined */ 0x42108423\n}\n\n// Compress arbitrarily large numbers into smi hashes.\nfunction hashNumber(n: number) {\n\tif (n !== n || n === Infinity) {\n\t\treturn 0\n\t}\n\tlet hash = n | 0\n\tif (hash !== n) {\n\t\thash ^= n * 0xffffffff\n\t}\n\twhile (n > 0xffffffff) {\n\t\tn /= 0xffffffff\n\t\thash ^= n\n\t}\n\treturn smi(hash)\n}\n\nfunction cachedHashString(string: string) {\n\tlet hashed = stringHashCache[string]\n\tif (hashed === undefined) {\n\t\thashed = hashString(string)\n\t\tif (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {\n\t\t\tSTRING_HASH_CACHE_SIZE = 0\n\t\t\tstringHashCache = {}\n\t\t}\n\t\tSTRING_HASH_CACHE_SIZE++\n\t\tstringHashCache[string] = hashed\n\t}\n\treturn hashed\n}\n\n// http://jsperf.com/hashing-strings\nfunction hashString(string: string) {\n\t// This is the hash from JVM\n\t// The hash code for a string is computed as\n\t// s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],\n\t// where s[i] is the ith character of the string and n is the length of\n\t// the string. We \"mod\" the result to make it between 0 (inclusive) and 2^31\n\t// (exclusive) by dropping high bits.\n\tlet hashed = 0\n\tfor (let ii = 0; ii < string.length; ii++) {\n\t\thashed = (31 * hashed + string.charCodeAt(ii)) | 0\n\t}\n\treturn smi(hashed)\n}\n\nfunction hashSymbol(sym: symbol) {\n\tlet hashed = symbolMap[sym]\n\tif (hashed !== undefined) {\n\t\treturn hashed\n\t}\n\n\thashed = nextHash()\n\n\tsymbolMap[sym] = hashed\n\n\treturn hashed\n}\n\nfunction hashJSObj(obj: object) {\n\tlet hashed = weakMap.get(obj)\n\tif (hashed !== undefined) {\n\t\treturn hashed\n\t}\n\n\thashed = nextHash()\n\n\tweakMap.set(obj, hashed)\n\n\treturn hashed\n}\n\nfunction valueOf(obj: any) {\n\treturn obj.valueOf !== defaultValueOf && typeof obj.valueOf === 'function'\n\t\t? obj.valueOf(obj)\n\t\t: obj\n}\n\nfunction nextHash() {\n\tconst nextHash = ++_objHashUID\n\tif (_objHashUID & 0x40000000) {\n\t\t_objHashUID = 0\n\t}\n\treturn nextHash\n}\n\n// If possible, use a WeakMap.\nconst weakMap = new WeakMap()\n\nconst symbolMap = Object.create(null)\n\nlet _objHashUID = 0\n\nconst STRING_HASH_CACHE_MIN_STRLEN = 16\nconst STRING_HASH_CACHE_MAX_SIZE = 255\nlet STRING_HASH_CACHE_SIZE = 0\nlet stringHashCache: Record<string, number> = {}\n\n// Constants describing the size of trie nodes.\nconst SHIFT = 5 // Resulted in best performance after ______?\nconst SIZE = 1 << SHIFT\nconst MASK = SIZE - 1\n\n// A consistent shared value representing \"not set\" which equals nothing other\n// than itself, and nothing that could be provided externally.\nconst NOT_SET = {}\n\ninterface Ref {\n\tvalue: boolean\n}\n\n// Boolean references, Rough equivalent of `bool &`.\nfunction MakeRef(): Ref {\n\treturn { value: false }\n}\n\nfunction SetRef(ref?: Ref): void {\n\tif (ref) {\n\t\tref.value = true\n\t}\n}\n\n// http://jsperf.com/copy-array-inline\nfunction arrCopy<I>(arr: Array<I>, offset?: number): Array<I> {\n\toffset = offset || 0\n\tconst len = Math.max(0, arr.length - offset)\n\tconst newArr: Array<I> = new Array(len)\n\tfor (let ii = 0; ii < len; ii++) {\n\t\t// We may want to guard for undefined values with `if (arr[ii + offset] !== undefined`, but ths should not happen by design\n\t\tnewArr[ii] = arr[ii + offset]\n\t}\n\treturn newArr\n}\n\nconst is = Object.is\n\nclass OwnerID {}\n\n/**\n * A persistent immutable map implementation based on a Hash Array Mapped Trie (HAMT) data structure.\n * Provides efficient operations for creating, reading, updating, and deleting key-value pairs while\n * maintaining structural sharing to minimize memory usage and maximize performance.\n *\n * This implementation is extracted and adapted from Immutable.js, optimized for tldraw's store needs.\n * All operations return new instances rather than modifying existing ones, ensuring immutability.\n *\n * @public\n * @example\n * ```ts\n * // Create a new map\n * const map = new ImmutableMap([\n *   ['key1', 'value1'],\n *   ['key2', 'value2']\n * ])\n *\n * // Add or update values\n * const updated = map.set('key3', 'value3')\n *\n * // Get values\n * const value = map.get('key1') // 'value1'\n *\n * // Delete values\n * const smaller = map.delete('key1')\n * ```\n */\nexport class ImmutableMap<K, V> {\n\t// @pragma Construction\n\t// @ts-ignore\n\t_root: MapNode<K, V>\n\t// @ts-ignore\n\tsize: number\n\t// @ts-ignore\n\t__ownerID: OwnerID\n\t// @ts-ignore\n\t__hash: number | undefined\n\t// @ts-ignore\n\t__altered: boolean\n\n\t/**\n\t * Creates a new ImmutableMap instance.\n\t *\n\t * @param value - An iterable of key-value pairs to populate the map, or null/undefined for an empty map\n\t * @example\n\t * ```ts\n\t * // Create from array of pairs\n\t * const map1 = new ImmutableMap([['a', 1], ['b', 2]])\n\t *\n\t * // Create empty map\n\t * const map2 = new ImmutableMap()\n\t *\n\t * // Create from another map\n\t * const map3 = new ImmutableMap(map1)\n\t * ```\n\t */\n\tconstructor(value?: Iterable<[K, V]> | null | undefined) {\n\t\t// @ts-ignore\n\t\treturn value === undefined || value === null\n\t\t\t? emptyMap()\n\t\t\t: value instanceof ImmutableMap\n\t\t\t\t? value\n\t\t\t\t: emptyMap().withMutations((map) => {\n\t\t\t\t\t\tfor (const [k, v] of value) {\n\t\t\t\t\t\t\tmap.set(k, v)\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t}\n\n\t/**\n\t * Gets the value associated with the specified key.\n\t *\n\t * @param k - The key to look up\n\t * @returns The value associated with the key, or undefined if not found\n\t * @example\n\t * ```ts\n\t * const map = new ImmutableMap([['key1', 'value1']])\n\t * console.log(map.get('key1')) // 'value1'\n\t * console.log(map.get('missing')) // undefined\n\t * ```\n\t */\n\tget(k: K): V | undefined\n\t/**\n\t * Gets the value associated with the specified key, with a fallback value.\n\t *\n\t * @param k - The key to look up\n\t * @param notSetValue - The value to return if the key is not found\n\t * @returns The value associated with the key, or the fallback value if not found\n\t * @example\n\t * ```ts\n\t * const map = new ImmutableMap([['key1', 'value1']])\n\t * console.log(map.get('key1', 'default')) // 'value1'\n\t * console.log(map.get('missing', 'default')) // 'default'\n\t * ```\n\t */\n\tget(k: K, notSetValue?: V): V {\n\t\treturn this._root ? this._root.get(0, undefined as any, k, notSetValue)! : notSetValue!\n\t}\n\n\t/**\n\t * Returns a new ImmutableMap with the specified key-value pair added or updated.\n\t * If the key already exists, its value is replaced. Otherwise, a new entry is created.\n\t *\n\t * @param k - The key to set\n\t * @param v - The value to associate with the key\n\t * @returns A new ImmutableMap with the key-value pair set\n\t * @example\n\t * ```ts\n\t * const map = new ImmutableMap([['a', 1]])\n\t * const updated = map.set('b', 2) // New map with both 'a' and 'b'\n\t * const replaced = map.set('a', 10) // New map with 'a' updated to 10\n\t * ```\n\t */\n\tset(k: K, v: V) {\n\t\treturn updateMap(this, k, v)\n\t}\n\n\t/**\n\t * Returns a new ImmutableMap with the specified key removed.\n\t * If the key doesn't exist, returns the same map instance.\n\t *\n\t * @param k - The key to remove\n\t * @returns A new ImmutableMap with the key removed, or the same instance if key not found\n\t * @example\n\t * ```ts\n\t * const map = new ImmutableMap([['a', 1], ['b', 2]])\n\t * const smaller = map.delete('a') // New map with only 'b'\n\t * const same = map.delete('missing') // Returns original map\n\t * ```\n\t */\n\tdelete(k: K) {\n\t\treturn updateMap(this, k, NOT_SET as any)\n\t}\n\n\t/**\n\t * Returns a new ImmutableMap with all specified keys removed.\n\t * This is more efficient than calling delete() multiple times.\n\t *\n\t * @param keys - An iterable of keys to remove\n\t * @returns A new ImmutableMap with all specified keys removed\n\t * @example\n\t * ```ts\n\t * const map = new ImmutableMap([['a', 1], ['b', 2], ['c', 3]])\n\t * const smaller = map.deleteAll(['a', 'c']) // New map with only 'b'\n\t * ```\n\t */\n\tdeleteAll(keys: Iterable<K>) {\n\t\treturn this.withMutations((map) => {\n\t\t\tfor (const key of keys) {\n\t\t\t\tmap.delete(key)\n\t\t\t}\n\t\t})\n\t}\n\n\t__ensureOwner(ownerID: OwnerID) {\n\t\tif (ownerID === this.__ownerID) {\n\t\t\treturn this\n\t\t}\n\t\tif (!ownerID) {\n\t\t\tif (this.size === 0) {\n\t\t\t\treturn emptyMap()\n\t\t\t}\n\t\t\tthis.__ownerID = ownerID\n\t\t\tthis.__altered = false\n\t\t\treturn this\n\t\t}\n\t\treturn makeMap(this.size, this._root, ownerID, this.__hash)\n\t}\n\n\t/**\n\t * Applies multiple mutations efficiently by creating a mutable copy,\n\t * applying all changes, then returning an immutable result.\n\t * This is more efficient than chaining multiple set/delete operations.\n\t *\n\t * @param fn - Function that receives a mutable copy and applies changes\n\t * @returns A new ImmutableMap with all mutations applied, or the same instance if no changes\n\t * @example\n\t * ```ts\n\t * const map = new ImmutableMap([['a', 1]])\n\t * const updated = map.withMutations(mutable => {\n\t *   mutable.set('b', 2)\n\t *   mutable.set('c', 3)\n\t *   mutable.delete('a')\n\t * }) // Efficiently applies all changes at once\n\t * ```\n\t */\n\twithMutations(fn: (mutable: this) => void): this {\n\t\tconst mutable = this.asMutable()\n\t\tfn(mutable)\n\t\treturn mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this\n\t}\n\n\t/**\n\t * Checks if this map instance has been altered during a mutation operation.\n\t * This is used internally to optimize mutations.\n\t *\n\t * @returns True if the map was altered, false otherwise\n\t * @internal\n\t */\n\twasAltered() {\n\t\treturn this.__altered\n\t}\n\n\t/**\n\t * Returns a mutable copy of this map that can be efficiently modified.\n\t * Multiple changes to the mutable copy are batched together.\n\t *\n\t * @returns A mutable copy of this map\n\t * @internal\n\t */\n\tasMutable() {\n\t\treturn this.__ownerID ? this : this.__ensureOwner(new OwnerID())\n\t}\n\n\t/**\n\t * Makes the map iterable, yielding key-value pairs.\n\t *\n\t * @returns An iterator over [key, value] pairs\n\t * @example\n\t * ```ts\n\t * const map = new ImmutableMap([['a', 1], ['b', 2]])\n\t * for (const [key, value] of map) {\n\t *   console.log(key, value) // 'a' 1, then 'b' 2\n\t * }\n\t * ```\n\t */\n\t[Symbol.iterator](): Iterator<[K, V]> {\n\t\treturn this.entries()[Symbol.iterator]()\n\t}\n\n\t/**\n\t * Returns an iterable of key-value pairs.\n\t *\n\t * @returns An iterable over [key, value] pairs\n\t * @example\n\t * ```ts\n\t * const map = new ImmutableMap([['a', 1], ['b', 2]])\n\t * const entries = Array.from(map.entries()) // [['a', 1], ['b', 2]]\n\t * ```\n\t */\n\tentries(): Iterable<[K, V]> {\n\t\treturn new MapIterator(this, ITERATE_ENTRIES, false)\n\t}\n\n\t/**\n\t * Returns an iterable of keys.\n\t *\n\t * @returns An iterable over keys\n\t * @example\n\t * ```ts\n\t * const map = new ImmutableMap([['a', 1], ['b', 2]])\n\t * const keys = Array.from(map.keys()) // ['a', 'b']\n\t * ```\n\t */\n\tkeys(): Iterable<K> {\n\t\treturn new MapIterator(this, ITERATE_KEYS, false)\n\t}\n\n\t/**\n\t * Returns an iterable of values.\n\t *\n\t * @returns An iterable over values\n\t * @example\n\t * ```ts\n\t * const map = new ImmutableMap([['a', 1], ['b', 2]])\n\t * const values = Array.from(map.values()) // [1, 2]\n\t * ```\n\t */\n\tvalues(): Iterable<V> {\n\t\treturn new MapIterator(this, ITERATE_VALUES, false)\n\t}\n}\n\ntype MapNode<K, V> =\n\t| ArrayMapNode<K, V>\n\t| BitmapIndexedNode<K, V>\n\t| HashArrayMapNode<K, V>\n\t| HashCollisionNode<K, V>\n\t| ValueNode<K, V>\n\n// #pragma Trie Nodes\n\nclass ArrayMapNode<K, V> {\n\tconstructor(\n\t\tpublic ownerID: OwnerID,\n\t\tpublic entries: Array<[K, V]>\n\t) {}\n\n\tget(_shift: unknown, _keyHash: unknown, key: K, notSetValue?: V) {\n\t\tconst entries = this.entries\n\t\tfor (let ii = 0, len = entries.length; ii < len; ii++) {\n\t\t\tif (is(key, entries[ii][0])) {\n\t\t\t\treturn entries[ii][1]\n\t\t\t}\n\t\t}\n\t\treturn notSetValue\n\t}\n\n\tupdate(\n\t\townerID: OwnerID,\n\t\t_shift: unknown,\n\t\t_keyHash: unknown,\n\t\tkey: K,\n\t\tvalue: V,\n\t\tdidChangeSize?: Ref,\n\t\tdidAlter?: Ref\n\t): MapNode<K, V> | undefined {\n\t\tconst removed = value === NOT_SET\n\n\t\tconst entries = this.entries\n\t\tlet idx = 0\n\t\tconst len = entries.length\n\t\tfor (; idx < len; idx++) {\n\t\t\tif (is(key, entries[idx][0])) {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tconst exists = idx < len\n\n\t\tif (exists ? entries[idx][1] === value : removed) {\n\t\t\treturn this\n\t\t}\n\n\t\tSetRef(didAlter)\n\t\t// eslint-disable-next-line @typescript-eslint/no-unused-expressions -- TODO enable eslint here\n\t\t;(removed || !exists) && SetRef(didChangeSize)\n\n\t\tif (removed && entries.length === 1) {\n\t\t\treturn // undefined\n\t\t}\n\n\t\tif (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {\n\t\t\treturn createNodes(ownerID, entries, key, value)\n\t\t}\n\n\t\tconst isEditable = ownerID && ownerID === this.ownerID\n\t\tconst newEntries = isEditable ? entries : arrCopy(entries)\n\n\t\tif (exists) {\n\t\t\tif (removed) {\n\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-unused-expressions -- TODO enable eslint here\n\t\t\t\tidx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop()!)\n\t\t\t} else {\n\t\t\t\tnewEntries[idx] = [key, value]\n\t\t\t}\n\t\t} else {\n\t\t\tnewEntries.push([key, value])\n\t\t}\n\n\t\tif (isEditable) {\n\t\t\tthis.entries = newEntries\n\t\t\treturn this\n\t\t}\n\n\t\treturn new ArrayMapNode(ownerID, newEntries)\n\t}\n}\n\nclass BitmapIndexedNode<K, V> {\n\tconstructor(\n\t\tpublic ownerID: OwnerID,\n\t\tpublic bitmap: number,\n\t\tpublic nodes: Array<MapNode<K, V>>\n\t) {}\n\n\tget(shift: number, keyHash: number, key: K, notSetValue?: V): V | undefined {\n\t\tif (keyHash === undefined) {\n\t\t\tkeyHash = hash(key)\n\t\t}\n\t\tconst bit = 1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK)\n\t\tconst bitmap = this.bitmap\n\t\treturn (bitmap & bit) === 0\n\t\t\t? notSetValue\n\t\t\t: this.nodes[popCount(bitmap & (bit - 1))].get(shift + SHIFT, keyHash, key, notSetValue)\n\t}\n\n\tupdate(\n\t\townerID: OwnerID,\n\t\tshift: number,\n\t\tkeyHash: number,\n\t\tkey: K,\n\t\tvalue: V,\n\t\tdidChangeSize?: Ref,\n\t\tdidAlter?: Ref\n\t): MapNode<K, V> | undefined {\n\t\tif (keyHash === undefined) {\n\t\t\tkeyHash = hash(key)\n\t\t}\n\t\tconst keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK\n\t\tconst bit = 1 << keyHashFrag\n\t\tconst bitmap = this.bitmap\n\t\tconst exists = (bitmap & bit) !== 0\n\n\t\tif (!exists && value === NOT_SET) {\n\t\t\treturn this\n\t\t}\n\n\t\tconst idx = popCount(bitmap & (bit - 1))\n\t\tconst nodes = this.nodes\n\t\tconst node = exists ? nodes[idx] : undefined\n\t\tconst newNode = updateNode(\n\t\t\tnode,\n\t\t\townerID,\n\t\t\tshift + SHIFT,\n\t\t\tkeyHash,\n\t\t\tkey,\n\t\t\tvalue,\n\t\t\tdidChangeSize,\n\t\t\tdidAlter\n\t\t)\n\n\t\tif (newNode === node) {\n\t\t\treturn this\n\t\t}\n\n\t\tif (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {\n\t\t\treturn expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode)\n\t\t}\n\n\t\tif (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {\n\t\t\treturn nodes[idx ^ 1]\n\t\t}\n\n\t\tif (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {\n\t\t\treturn newNode\n\t\t}\n\n\t\tconst isEditable = ownerID && ownerID === this.ownerID\n\t\tconst newBitmap = exists ? (newNode ? bitmap : bitmap ^ bit) : bitmap | bit\n\t\tconst newNodes = exists\n\t\t\t? newNode\n\t\t\t\t? setAt(nodes, idx, newNode, isEditable)\n\t\t\t\t: spliceOut(nodes, idx, isEditable)\n\t\t\t: spliceIn(nodes, idx, newNode, isEditable)\n\n\t\tif (isEditable) {\n\t\t\tthis.bitmap = newBitmap\n\t\t\tthis.nodes = newNodes\n\t\t\treturn this\n\t\t}\n\n\t\treturn new BitmapIndexedNode(ownerID, newBitmap, newNodes)\n\t}\n}\n\nclass HashArrayMapNode<K, V> {\n\tconstructor(\n\t\tpublic ownerID: OwnerID,\n\t\tpublic count: number,\n\t\tpublic nodes: Array<MapNode<K, V>>\n\t) {}\n\n\tget(shift: number, keyHash: number, key: K, notSetValue?: V): V | undefined {\n\t\tif (keyHash === undefined) {\n\t\t\tkeyHash = hash(key)\n\t\t}\n\t\tconst idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK\n\t\tconst node = this.nodes[idx]\n\t\treturn node ? node.get(shift + SHIFT, keyHash, key, notSetValue) : notSetValue\n\t}\n\n\tupdate(\n\t\townerID: OwnerID,\n\t\tshift: number,\n\t\tkeyHash: number,\n\t\tkey: K,\n\t\tvalue: V,\n\t\tdidChangeSize?: Ref,\n\t\tdidAlter?: Ref\n\t) {\n\t\tif (keyHash === undefined) {\n\t\t\tkeyHash = hash(key)\n\t\t}\n\t\tconst idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK\n\t\tconst removed = value === NOT_SET\n\t\tconst nodes = this.nodes\n\t\tconst node = nodes[idx]\n\n\t\tif (removed && !node) {\n\t\t\treturn this\n\t\t}\n\n\t\tconst newNode = updateNode(\n\t\t\tnode,\n\t\t\townerID,\n\t\t\tshift + SHIFT,\n\t\t\tkeyHash,\n\t\t\tkey,\n\t\t\tvalue,\n\t\t\tdidChangeSize,\n\t\t\tdidAlter\n\t\t)\n\t\tif (newNode === node) {\n\t\t\treturn this\n\t\t}\n\n\t\tlet newCount = this.count\n\t\tif (!node) {\n\t\t\tnewCount++\n\t\t} else if (!newNode) {\n\t\t\tnewCount--\n\t\t\tif (newCount < MIN_HASH_ARRAY_MAP_SIZE) {\n\t\t\t\treturn packNodes(ownerID, nodes, newCount, idx)\n\t\t\t}\n\t\t}\n\n\t\tconst isEditable = ownerID && ownerID === this.ownerID\n\t\tconst newNodes = setAt(nodes, idx, newNode!, isEditable)\n\n\t\tif (isEditable) {\n\t\t\tthis.count = newCount\n\t\t\tthis.nodes = newNodes\n\t\t\treturn this\n\t\t}\n\n\t\treturn new HashArrayMapNode(ownerID, newCount, newNodes)\n\t}\n}\n\nclass HashCollisionNode<K, V> {\n\tconstructor(\n\t\tpublic ownerID: OwnerID,\n\t\tpublic keyHash: number,\n\t\tpublic entries: Array<[K, V]>\n\t) {}\n\n\tget(shift: number, keyHash: number, key: K, notSetValue?: V) {\n\t\tconst entries = this.entries\n\t\tfor (let ii = 0, len = entries.length; ii < len; ii++) {\n\t\t\tif (is(key, entries[ii][0])) {\n\t\t\t\treturn entries[ii][1]\n\t\t\t}\n\t\t}\n\t\treturn notSetValue\n\t}\n\n\tupdate(\n\t\townerID: OwnerID,\n\t\tshift: number,\n\t\tkeyHash: number,\n\t\tkey: K,\n\t\tvalue: V,\n\t\tdidChangeSize?: Ref,\n\t\tdidAlter?: Ref\n\t): MapNode<K, V> {\n\t\tif (keyHash === undefined) {\n\t\t\tkeyHash = hash(key)\n\t\t}\n\n\t\tconst removed = value === NOT_SET\n\n\t\tif (keyHash !== this.keyHash) {\n\t\t\tif (removed) {\n\t\t\t\treturn this\n\t\t\t}\n\t\t\tSetRef(didAlter)\n\t\t\tSetRef(didChangeSize)\n\t\t\treturn mergeIntoNode(this, ownerID, shift, keyHash, [key, value])\n\t\t}\n\n\t\tconst entries = this.entries\n\t\tlet idx = 0\n\t\tconst len = entries.length\n\t\tfor (; idx < len; idx++) {\n\t\t\tif (is(key, entries[idx][0])) {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tconst exists = idx < len\n\n\t\tif (exists ? entries[idx][1] === value : removed) {\n\t\t\treturn this\n\t\t}\n\n\t\tSetRef(didAlter)\n\t\t// eslint-disable-next-line @typescript-eslint/no-unused-expressions -- TODO enable eslint here\n\t\t;(removed || !exists) && SetRef(didChangeSize)\n\n\t\tif (removed && len === 2) {\n\t\t\treturn new ValueNode(ownerID, this.keyHash, entries[idx ^ 1])\n\t\t}\n\n\t\tconst isEditable = ownerID && ownerID === this.ownerID\n\t\tconst newEntries = isEditable ? entries : arrCopy(entries)\n\n\t\tif (exists) {\n\t\t\tif (removed) {\n\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-unused-expressions -- TODO enable eslint here\n\t\t\t\tidx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop()!)\n\t\t\t} else {\n\t\t\t\tnewEntries[idx] = [key, value]\n\t\t\t}\n\t\t} else {\n\t\t\tnewEntries.push([key, value])\n\t\t}\n\n\t\tif (isEditable) {\n\t\t\tthis.entries = newEntries\n\t\t\treturn this\n\t\t}\n\n\t\treturn new HashCollisionNode(ownerID, this.keyHash, newEntries)\n\t}\n}\n\nclass ValueNode<K, V> {\n\tconstructor(\n\t\tpublic ownerID: OwnerID,\n\t\tpublic keyHash: number | undefined,\n\t\tpublic entry: [K, V]\n\t) {}\n\n\tget(shift: number, keyHash: number, key: K, notSetValue?: V) {\n\t\treturn is(key, this.entry[0]) ? this.entry[1] : notSetValue\n\t}\n\n\tupdate(\n\t\townerID: OwnerID,\n\t\tshift: number,\n\t\tkeyHash: number | undefined,\n\t\tkey: K,\n\t\tvalue: V,\n\t\tdidChangeSize?: Ref,\n\t\tdidAlter?: Ref\n\t) {\n\t\tconst removed = value === NOT_SET\n\t\tconst keyMatch = is(key, this.entry[0])\n\t\tif (keyMatch ? value === this.entry[1] : removed) {\n\t\t\treturn this\n\t\t}\n\n\t\tSetRef(didAlter)\n\n\t\tif (removed) {\n\t\t\tSetRef(didChangeSize)\n\t\t\treturn // undefined\n\t\t}\n\n\t\tif (keyMatch) {\n\t\t\tif (ownerID && ownerID === this.ownerID) {\n\t\t\t\tthis.entry[1] = value\n\t\t\t\treturn this\n\t\t\t}\n\t\t\treturn new ValueNode(ownerID, this.keyHash, [key, value])\n\t\t}\n\n\t\tSetRef(didChangeSize)\n\t\treturn mergeIntoNode(this, ownerID, shift, hash(key), [key, value])\n\t}\n}\n\n// #pragma Iterators\n\nclass MapIterator<K, V> implements Iterator<any>, Iterable<any> {\n\t_stack\n\n\tconstructor(\n\t\tmap: ImmutableMap<K, V>,\n\t\tpublic _type: IterationType,\n\t\tpublic _reverse: boolean\n\t) {\n\t\tthis._stack = map._root && mapIteratorFrame<K, V>(map._root)\n\t}\n\n\t[Symbol.iterator](): Iterator<any> {\n\t\treturn this\n\t}\n\n\tnext() {\n\t\tconst type = this._type\n\t\tlet stack = this._stack\n\t\twhile (stack) {\n\t\t\tconst node = stack.node as any\n\t\t\tconst index = stack.index++\n\t\t\tlet maxIndex\n\t\t\tif (node.entry) {\n\t\t\t\tif (index === 0) {\n\t\t\t\t\treturn mapIteratorValue(type, node.entry)\n\t\t\t\t}\n\t\t\t} else if ('entries' in node && node.entries) {\n\t\t\t\tmaxIndex = node.entries.length - 1\n\t\t\t\tif (index <= maxIndex) {\n\t\t\t\t\treturn mapIteratorValue(type, node.entries[this._reverse ? maxIndex - index : index])\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmaxIndex = node.nodes.length - 1\n\t\t\t\tif (index <= maxIndex) {\n\t\t\t\t\tconst subNode = node.nodes[this._reverse ? maxIndex - index : index]\n\t\t\t\t\tif (subNode) {\n\t\t\t\t\t\tif (subNode.entry) {\n\t\t\t\t\t\t\treturn mapIteratorValue(type, subNode.entry)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstack = this._stack = mapIteratorFrame(subNode, stack)\n\t\t\t\t\t}\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\t\t\tstack = this._stack = this._stack.__prev!\n\t\t}\n\t\treturn iteratorDone() as any\n\t}\n}\n\nfunction mapIteratorValue<K, V>(type: IterationType, entry: [K, V]) {\n\treturn iteratorValue(type, entry[0], entry[1])\n}\n\ninterface IStack {\n\tnode: MapNode<unknown, unknown>\n\tindex: number\n\t__prev?: IStack\n}\n\nfunction mapIteratorFrame<K, V>(\n\tnode: MapNode<K, V>,\n\tprev?: { node: MapNode<K, V>; index: number; __prev?: IStack }\n): IStack {\n\treturn {\n\t\tnode: node,\n\t\tindex: 0,\n\t\t__prev: prev,\n\t}\n}\n\nconst ITERATE_KEYS = 0\nconst ITERATE_VALUES = 1\nconst ITERATE_ENTRIES = 2\n\ntype IterationType = typeof ITERATE_KEYS | typeof ITERATE_VALUES | typeof ITERATE_ENTRIES\n\nfunction iteratorValue<K, V>(\n\ttype: IterationType,\n\tk: K,\n\tv: V,\n\titeratorResult?: IteratorResult<any>\n) {\n\tconst value = type === ITERATE_KEYS ? k : type === ITERATE_VALUES ? v : [k, v]\n\t// eslint-disable-next-line @typescript-eslint/no-unused-expressions -- TODO enable eslint here\n\titeratorResult\n\t\t? (iteratorResult.value = value)\n\t\t: (iteratorResult = {\n\t\t\t\tvalue: value,\n\t\t\t\tdone: false,\n\t\t\t})\n\treturn iteratorResult\n}\n\n/**\n * Creates a completed iterator result object indicating iteration is finished.\n * Used internally by map iterators to signal the end of iteration.\n *\n * @returns An IteratorResult object with done set to true and value as undefined\n * @public\n * @example\n * ```ts\n * // Used internally by iterators\n * const result = iteratorDone()\n * console.log(result) // { value: undefined, done: true }\n * ```\n */\nexport function iteratorDone() {\n\treturn { value: undefined, done: true }\n}\n\nfunction makeMap<K, V>(size: number, root?: MapNode<K, V>, ownerID?: OwnerID, hash?: number) {\n\tconst map = Object.create(ImmutableMap.prototype)\n\tmap.size = size\n\tmap._root = root\n\tmap.__ownerID = ownerID\n\tmap.__hash = hash\n\tmap.__altered = false\n\treturn map\n}\n\nlet EMPTY_MAP: ImmutableMap<unknown, unknown>\n/**\n * Returns a singleton empty ImmutableMap instance.\n * This function is optimized to return the same empty map instance for all calls,\n * saving memory when working with many empty maps.\n *\n * @returns An empty ImmutableMap instance\n * @public\n * @example\n * ```ts\n * // Get an empty map\n * const empty = emptyMap<string, number>()\n * console.log(empty.size) // 0\n *\n * // All empty maps are the same instance\n * const empty1 = emptyMap()\n * const empty2 = emptyMap()\n * console.log(empty1 === empty2) // true\n * ```\n */\nexport function emptyMap<K, V>(): ImmutableMap<K, V> {\n\treturn (EMPTY_MAP as any) || (EMPTY_MAP = makeMap(0))\n}\n\nfunction updateMap<K, V>(map: ImmutableMap<K, V>, k: K, v: V) {\n\tlet newRoot\n\tlet newSize\n\tif (!map._root) {\n\t\tif (v === NOT_SET) {\n\t\t\treturn map\n\t\t}\n\t\tnewSize = 1\n\t\tnewRoot = new ArrayMapNode(map.__ownerID, [[k, v]])\n\t} else {\n\t\tconst didChangeSize = MakeRef()\n\t\tconst didAlter = MakeRef()\n\t\tnewRoot = updateNode(map._root, map.__ownerID, 0, undefined, k, v, didChangeSize, didAlter)\n\t\tif (!didAlter.value) {\n\t\t\treturn map\n\t\t}\n\t\tnewSize = map.size + (didChangeSize.value ? (v === NOT_SET ? -1 : 1) : 0)\n\t}\n\tif (map.__ownerID) {\n\t\tmap.size = newSize\n\t\tmap._root = newRoot as any\n\t\tmap.__hash = undefined\n\t\tmap.__altered = true\n\t\treturn map\n\t}\n\treturn newRoot ? makeMap(newSize, newRoot) : emptyMap()\n}\n\nfunction updateNode<K, V>(\n\tnode: MapNode<K, V> | undefined,\n\townerID: OwnerID,\n\tshift: number,\n\tkeyHash: number | undefined,\n\tkey: K,\n\tvalue: V,\n\tdidChangeSize?: Ref,\n\tdidAlter?: Ref\n): MapNode<K, V> | undefined {\n\tif (!node) {\n\t\tif (value === NOT_SET) {\n\t\t\treturn node\n\t\t}\n\t\tSetRef(didAlter)\n\t\tSetRef(didChangeSize)\n\t\treturn new ValueNode(ownerID, keyHash, [key, value])\n\t}\n\treturn node.update(ownerID, shift, keyHash!, key, value, didChangeSize, didAlter) as any\n}\n\nfunction isLeafNode(node: MapNode<unknown, unknown>) {\n\treturn node.constructor === ValueNode || node.constructor === HashCollisionNode\n}\n\nfunction mergeIntoNode<K, V>(\n\tnode: any,\n\townerID: OwnerID,\n\tshift: number,\n\tkeyHash: number,\n\tentry: [K, V]\n): MapNode<K, V> {\n\tif (node.keyHash === keyHash) {\n\t\treturn new HashCollisionNode(ownerID, keyHash, [node.entry, entry])\n\t}\n\n\tconst idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK\n\tconst idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK\n\n\tlet newNode\n\tconst nodes =\n\t\tidx1 === idx2\n\t\t\t? [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)]\n\t\t\t: ((newNode = new ValueNode(ownerID, keyHash, entry)),\n\t\t\t\tidx1 < idx2 ? [node, newNode] : [newNode, node])\n\n\treturn new BitmapIndexedNode(ownerID, (1 << idx1) | (1 << idx2), nodes)\n}\n\nfunction createNodes<K, V>(ownerID: OwnerID, entries: [K, V][], key: K, value: V) {\n\tif (!ownerID) {\n\t\townerID = new OwnerID()\n\t}\n\tlet node: MapNode<K, V> = new ValueNode(ownerID, hash(key), [key, value])\n\tfor (let ii = 0; ii < entries.length; ii++) {\n\t\tconst entry = entries[ii]\n\t\tnode = node.update(ownerID, 0, undefined as any as number, entry[0], entry[1]) as any\n\t}\n\treturn node\n}\n\nfunction packNodes<K, V>(\n\townerID: OwnerID,\n\tnodes: MapNode<K, V>[],\n\tcount: number,\n\texcluding: number\n) {\n\tlet bitmap = 0\n\tlet packedII = 0\n\tconst packedNodes = new Array(count)\n\tfor (let ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {\n\t\tconst node = nodes[ii]\n\t\tif (node !== undefined && ii !== excluding) {\n\t\t\tbitmap |= bit\n\t\t\tpackedNodes[packedII++] = node\n\t\t}\n\t}\n\treturn new BitmapIndexedNode(ownerID, bitmap, packedNodes)\n}\n\nfunction expandNodes<K, V>(\n\townerID: OwnerID,\n\tnodes: MapNode<K, V>[],\n\tbitmap: number,\n\tincluding: number,\n\tnode: MapNode<K, V>\n): MapNode<K, V> {\n\tlet count = 0\n\tconst expandedNodes = new Array(SIZE)\n\tfor (let ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {\n\t\texpandedNodes[ii] = bitmap & 1 ? nodes[count++] : undefined\n\t}\n\texpandedNodes[including] = node\n\treturn new HashArrayMapNode(ownerID, count + 1, expandedNodes)\n}\n\nfunction popCount(x: number) {\n\tx -= (x >> 1) & 0x55555555\n\tx = (x & 0x33333333) + ((x >> 2) & 0x33333333)\n\tx = (x + (x >> 4)) & 0x0f0f0f0f\n\tx += x >> 8\n\tx += x >> 16\n\treturn x & 0x7f\n}\n\nfunction setAt<T>(array: T[], idx: number, val: T, canEdit: boolean): T[] {\n\tconst newArray = canEdit ? array : arrCopy(array)\n\tnewArray[idx] = val\n\treturn newArray\n}\n\nfunction spliceIn<T>(array: T[], idx: number, val: T, canEdit: boolean): T[] {\n\tconst newLen = array.length + 1\n\tif (canEdit && idx + 1 === newLen) {\n\t\tarray[idx] = val\n\t\treturn array\n\t}\n\tconst newArray = new Array<T>(newLen)\n\tlet after = 0\n\tfor (let ii = 0; ii < newLen; ii++) {\n\t\tif (ii === idx) {\n\t\t\tnewArray[ii] = val\n\t\t\tafter = -1\n\t\t} else {\n\t\t\tnewArray[ii] = array[ii + after]\n\t\t}\n\t}\n\treturn newArray\n}\n\nfunction spliceOut<T>(array: T[], idx: number, canEdit: boolean) {\n\tconst newLen = array.length - 1\n\tif (canEdit && idx === newLen) {\n\t\tarray.pop()\n\t\treturn array\n\t}\n\tconst newArray = new Array(newLen)\n\tlet after = 0\n\tfor (let ii = 0; ii < newLen; ii++) {\n\t\tif (ii === idx) {\n\t\t\tafter = 1\n\t\t}\n\t\tnewArray[ii] = array[ii + after]\n\t}\n\treturn newArray\n}\n\nconst MAX_ARRAY_MAP_SIZE = SIZE / 4\nconst MAX_BITMAP_INDEXED_SIZE = SIZE / 2\nconst MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA,SAAS,IAAI,KAAa;AACzB,SAAS,QAAQ,IAAK,aAAe,MAAM;AAC5C;AAEA,MAAM,iBAAiB,OAAO,UAAU;AAExC,SAAS,KAAK,GAAQ;AACrB,MAAI,KAAK,MAAM;AACd,WAAO,YAAY,CAAC;AAAA,EACrB;AAEA,MAAI,OAAO,EAAE,aAAa,YAAY;AAErC,WAAO,IAAI,EAAE,SAAS,CAAC,CAAC;AAAA,EACzB;AAEA,QAAM,IAAI,QAAQ,CAAC;AAEnB,MAAI,KAAK,MAAM;AACd,WAAO,YAAY,CAAC;AAAA,EACrB;AAEA,UAAQ,OAAO,GAAG;AAAA,IACjB,KAAK;AAIJ,aAAO,IAAI,aAAa;AAAA,IACzB,KAAK;AACJ,aAAO,WAAW,CAAC;AAAA,IACpB,KAAK;AACJ,aAAO,EAAE,SAAS,+BAA+B,iBAAiB,CAAC,IAAI,WAAW,CAAC;AAAA,IACpF,KAAK;AAAA,IACL,KAAK;AACJ,aAAO,UAAU,CAAC;AAAA,IACnB,KAAK;AACJ,aAAO,WAAW,CAAC;AAAA,IACpB;AACC,UAAI,OAAO,EAAE,aAAa,YAAY;AACrC,eAAO,WAAW,EAAE,SAAS,CAAC;AAAA,MAC/B;AACA,YAAM,IAAI,MAAM,gBAAgB,OAAO,IAAI,oBAAoB;AAAA,EACjE;AACD;AAEA,SAAS,YAAY,SAA2B;AAC/C,SAAO,YAAY,OAAO;AAAA;AAAA,IAA6B;AAAA;AACxD;AAGA,SAAS,WAAW,GAAW;AAC9B,MAAI,MAAM,KAAK,MAAM,UAAU;AAC9B,WAAO;AAAA,EACR;AACA,MAAIA,QAAO,IAAI;AACf,MAAIA,UAAS,GAAG;AACf,IAAAA,SAAQ,IAAI;AAAA,EACb;AACA,SAAO,IAAI,YAAY;AACtB,SAAK;AACL,IAAAA,SAAQ;AAAA,EACT;AACA,SAAO,IAAIA,KAAI;AAChB;AAEA,SAAS,iBAAiB,QAAgB;AACzC,MAAI,SAAS,gBAAgB,MAAM;AACnC,MAAI,WAAW,QAAW;AACzB,aAAS,WAAW,MAAM;AAC1B,QAAI,2BAA2B,4BAA4B;AAC1D,+BAAyB;AACzB,wBAAkB,CAAC;AAAA,IACpB;AACA;AACA,oBAAgB,MAAM,IAAI;AAAA,EAC3B;AACA,SAAO;AACR;AAGA,SAAS,WAAW,QAAgB;AAOnC,MAAI,SAAS;AACb,WAAS,KAAK,GAAG,KAAK,OAAO,QAAQ,MAAM;AAC1C,aAAU,KAAK,SAAS,OAAO,WAAW,EAAE,IAAK;AAAA,EAClD;AACA,SAAO,IAAI,MAAM;AAClB;AAEA,SAAS,WAAW,KAAa;AAChC,MAAI,SAAS,UAAU,GAAG;AAC1B,MAAI,WAAW,QAAW;AACzB,WAAO;AAAA,EACR;AAEA,WAAS,SAAS;AAElB,YAAU,GAAG,IAAI;AAEjB,SAAO;AACR;AAEA,SAAS,UAAU,KAAa;AAC/B,MAAI,SAAS,QAAQ,IAAI,GAAG;AAC5B,MAAI,WAAW,QAAW;AACzB,WAAO;AAAA,EACR;AAEA,WAAS,SAAS;AAElB,UAAQ,IAAI,KAAK,MAAM;AAEvB,SAAO;AACR;AAEA,SAAS,QAAQ,KAAU;AAC1B,SAAO,IAAI,YAAY,kBAAkB,OAAO,IAAI,YAAY,aAC7D,IAAI,QAAQ,GAAG,IACf;AACJ;AAEA,SAAS,WAAW;AACnB,QAAMC,YAAW,EAAE;AACnB,MAAI,cAAc,YAAY;AAC7B,kBAAc;AAAA,EACf;AACA,SAAOA;AACR;AAGA,MAAM,UAAU,oBAAI,QAAQ;AAE5B,MAAM,YAAY,uBAAO,OAAO,IAAI;AAEpC,IAAI,cAAc;AAElB,MAAM,+BAA+B;AACrC,MAAM,6BAA6B;AACnC,IAAI,yBAAyB;AAC7B,IAAI,kBAA0C,CAAC;AAG/C,MAAM,QAAQ;AACd,MAAM,OAAO,KAAK;AAClB,MAAM,OAAO,OAAO;AAIpB,MAAM,UAAU,CAAC;AAOjB,SAAS,UAAe;AACvB,SAAO,EAAE,OAAO,MAAM;AACvB;AAEA,SAAS,OAAO,KAAiB;AAChC,MAAI,KAAK;AACR,QAAI,QAAQ;AAAA,EACb;AACD;AAGA,SAAS,QAAW,KAAe,QAA2B;AAC7D,WAAS,UAAU;AACnB,QAAM,MAAM,KAAK,IAAI,GAAG,IAAI,SAAS,MAAM;AAC3C,QAAM,SAAmB,IAAI,MAAM,GAAG;AACtC,WAAS,KAAK,GAAG,KAAK,KAAK,MAAM;AAEhC,WAAO,EAAE,IAAI,IAAI,KAAK,MAAM;AAAA,EAC7B;AACA,SAAO;AACR;AAEA,MAAM,KAAK,OAAO;AAElB,MAAM,QAAQ;AAAC;AA6BR,MAAM,aAAmB;AAAA;AAAA;AAAA,EAG/B;AAAA;AAAA,EAEA;AAAA;AAAA,EAEA;AAAA;AAAA,EAEA;AAAA;AAAA,EAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAkBA,YAAY,OAA6C;AAExD,WAAO,UAAU,UAAa,UAAU,OACrC,SAAS,IACT,iBAAiB,eAChB,QACA,SAAS,EAAE,cAAc,CAAC,QAAQ;AAClC,iBAAW,CAAC,GAAG,CAAC,KAAK,OAAO;AAC3B,YAAI,IAAI,GAAG,CAAC;AAAA,MACb;AAAA,IACD,CAAC;AAAA,EACL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EA4BA,IAAI,GAAM,aAAoB;AAC7B,WAAO,KAAK,QAAQ,KAAK,MAAM,IAAI,GAAG,QAAkB,GAAG,WAAW,IAAK;AAAA,EAC5E;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAgBA,IAAI,GAAM,GAAM;AACf,WAAO,UAAU,MAAM,GAAG,CAAC;AAAA,EAC5B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAeA,OAAO,GAAM;AACZ,WAAO,UAAU,MAAM,GAAG,OAAc;AAAA,EACzC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAcA,UAAU,MAAmB;AAC5B,WAAO,KAAK,cAAc,CAAC,QAAQ;AAClC,iBAAW,OAAO,MAAM;AACvB,YAAI,OAAO,GAAG;AAAA,MACf;AAAA,IACD,CAAC;AAAA,EACF;AAAA,EAEA,cAAc,SAAkB;AAC/B,QAAI,YAAY,KAAK,WAAW;AAC/B,aAAO;AAAA,IACR;AACA,QAAI,CAAC,SAAS;AACb,UAAI,KAAK,SAAS,GAAG;AACpB,eAAO,SAAS;AAAA,MACjB;AACA,WAAK,YAAY;AACjB,WAAK,YAAY;AACjB,aAAO;AAAA,IACR;AACA,WAAO,QAAQ,KAAK,MAAM,KAAK,OAAO,SAAS,KAAK,MAAM;AAAA,EAC3D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAmBA,cAAc,IAAmC;AAChD,UAAM,UAAU,KAAK,UAAU;AAC/B,OAAG,OAAO;AACV,WAAO,QAAQ,WAAW,IAAI,QAAQ,cAAc,KAAK,SAAS,IAAI;AAAA,EACvE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,aAAa;AACZ,WAAO,KAAK;AAAA,EACb;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,YAAY;AACX,WAAO,KAAK,YAAY,OAAO,KAAK,cAAc,IAAI,QAAQ,CAAC;AAAA,EAChE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAcA,CAAC,OAAO,QAAQ,IAAsB;AACrC,WAAO,KAAK,QAAQ,EAAE,OAAO,QAAQ,EAAE;AAAA,EACxC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYA,UAA4B;AAC3B,WAAO,IAAI,YAAY,MAAM,iBAAiB,KAAK;AAAA,EACpD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYA,OAAoB;AACnB,WAAO,IAAI,YAAY,MAAM,cAAc,KAAK;AAAA,EACjD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYA,SAAsB;AACrB,WAAO,IAAI,YAAY,MAAM,gBAAgB,KAAK;AAAA,EACnD;AACD;AAWA,MAAM,aAAmB;AAAA,EACxB,YACQ,SACA,SACN;AAFM;AACA;AAAA,EACL;AAAA,EAEH,IAAI,QAAiB,UAAmB,KAAQ,aAAiB;AAChE,UAAM,UAAU,KAAK;AACrB,aAAS,KAAK,GAAG,MAAM,QAAQ,QAAQ,KAAK,KAAK,MAAM;AACtD,UAAI,GAAG,KAAK,QAAQ,EAAE,EAAE,CAAC,CAAC,GAAG;AAC5B,eAAO,QAAQ,EAAE,EAAE,CAAC;AAAA,MACrB;AAAA,IACD;AACA,WAAO;AAAA,EACR;AAAA,EAEA,OACC,SACA,QACA,UACA,KACA,OACA,eACA,UAC4B;AAC5B,UAAM,UAAU,UAAU;AAE1B,UAAM,UAAU,KAAK;AACrB,QAAI,MAAM;AACV,UAAM,MAAM,QAAQ;AACpB,WAAO,MAAM,KAAK,OAAO;AACxB,UAAI,GAAG,KAAK,QAAQ,GAAG,EAAE,CAAC,CAAC,GAAG;AAC7B;AAAA,MACD;AAAA,IACD;AACA,UAAM,SAAS,MAAM;AAErB,QAAI,SAAS,QAAQ,GAAG,EAAE,CAAC,MAAM,QAAQ,SAAS;AACjD,aAAO;AAAA,IACR;AAEA,WAAO,QAAQ;AAEd,KAAC,WAAW,CAAC,WAAW,OAAO,aAAa;AAE7C,QAAI,WAAW,QAAQ,WAAW,GAAG;AACpC;AAAA,IACD;AAEA,QAAI,CAAC,UAAU,CAAC,WAAW,QAAQ,UAAU,oBAAoB;AAChE,aAAO,YAAY,SAAS,SAAS,KAAK,KAAK;AAAA,IAChD;AAEA,UAAM,aAAa,WAAW,YAAY,KAAK;AAC/C,UAAM,aAAa,aAAa,UAAU,QAAQ,OAAO;AAEzD,QAAI,QAAQ;AACX,UAAI,SAAS;AAEZ,gBAAQ,MAAM,IAAI,WAAW,IAAI,IAAK,WAAW,GAAG,IAAI,WAAW,IAAI;AAAA,MACxE,OAAO;AACN,mBAAW,GAAG,IAAI,CAAC,KAAK,KAAK;AAAA,MAC9B;AAAA,IACD,OAAO;AACN,iBAAW,KAAK,CAAC,KAAK,KAAK,CAAC;AAAA,IAC7B;AAEA,QAAI,YAAY;AACf,WAAK,UAAU;AACf,aAAO;AAAA,IACR;AAEA,WAAO,IAAI,aAAa,SAAS,UAAU;AAAA,EAC5C;AACD;AAEA,MAAM,kBAAwB;AAAA,EAC7B,YACQ,SACA,QACA,OACN;AAHM;AACA;AACA;AAAA,EACL;AAAA,EAEH,IAAI,OAAe,SAAiB,KAAQ,aAAgC;AAC3E,QAAI,YAAY,QAAW;AAC1B,gBAAU,KAAK,GAAG;AAAA,IACnB;AACA,UAAM,MAAM,OAAO,UAAU,IAAI,UAAU,YAAY,SAAS;AAChE,UAAM,SAAS,KAAK;AACpB,YAAQ,SAAS,SAAS,IACvB,cACA,KAAK,MAAM,SAAS,SAAU,MAAM,CAAE,CAAC,EAAE,IAAI,QAAQ,OAAO,SAAS,KAAK,WAAW;AAAA,EACzF;AAAA,EAEA,OACC,SACA,OACA,SACA,KACA,OACA,eACA,UAC4B;AAC5B,QAAI,YAAY,QAAW;AAC1B,gBAAU,KAAK,GAAG;AAAA,IACnB;AACA,UAAM,eAAe,UAAU,IAAI,UAAU,YAAY,SAAS;AAClE,UAAM,MAAM,KAAK;AACjB,UAAM,SAAS,KAAK;AACpB,UAAM,UAAU,SAAS,SAAS;AAElC,QAAI,CAAC,UAAU,UAAU,SAAS;AACjC,aAAO;AAAA,IACR;AAEA,UAAM,MAAM,SAAS,SAAU,MAAM,CAAE;AACvC,UAAM,QAAQ,KAAK;AACnB,UAAM,OAAO,SAAS,MAAM,GAAG,IAAI;AACnC,UAAM,UAAU;AAAA,MACf;AAAA,MACA;AAAA,MACA,QAAQ;AAAA,MACR;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACD;AAEA,QAAI,YAAY,MAAM;AACrB,aAAO;AAAA,IACR;AAEA,QAAI,CAAC,UAAU,WAAW,MAAM,UAAU,yBAAyB;AAClE,aAAO,YAAY,SAAS,OAAO,QAAQ,aAAa,OAAO;AAAA,IAChE;AAEA,QAAI,UAAU,CAAC,WAAW,MAAM,WAAW,KAAK,WAAW,MAAM,MAAM,CAAC,CAAC,GAAG;AAC3E,aAAO,MAAM,MAAM,CAAC;AAAA,IACrB;AAEA,QAAI,UAAU,WAAW,MAAM,WAAW,KAAK,WAAW,OAAO,GAAG;AACnE,aAAO;AAAA,IACR;AAEA,UAAM,aAAa,WAAW,YAAY,KAAK;AAC/C,UAAM,YAAY,SAAU,UAAU,SAAS,SAAS,MAAO,SAAS;AACxE,UAAM,WAAW,SACd,UACC,MAAM,OAAO,KAAK,SAAS,UAAU,IACrC,UAAU,OAAO,KAAK,UAAU,IACjC,SAAS,OAAO,KAAK,SAAS,UAAU;AAE3C,QAAI,YAAY;AACf,WAAK,SAAS;AACd,WAAK,QAAQ;AACb,aAAO;AAAA,IACR;AAEA,WAAO,IAAI,kBAAkB,SAAS,WAAW,QAAQ;AAAA,EAC1D;AACD;AAEA,MAAM,iBAAuB;AAAA,EAC5B,YACQ,SACA,OACA,OACN;AAHM;AACA;AACA;AAAA,EACL;AAAA,EAEH,IAAI,OAAe,SAAiB,KAAQ,aAAgC;AAC3E,QAAI,YAAY,QAAW;AAC1B,gBAAU,KAAK,GAAG;AAAA,IACnB;AACA,UAAM,OAAO,UAAU,IAAI,UAAU,YAAY,SAAS;AAC1D,UAAM,OAAO,KAAK,MAAM,GAAG;AAC3B,WAAO,OAAO,KAAK,IAAI,QAAQ,OAAO,SAAS,KAAK,WAAW,IAAI;AAAA,EACpE;AAAA,EAEA,OACC,SACA,OACA,SACA,KACA,OACA,eACA,UACC;AACD,QAAI,YAAY,QAAW;AAC1B,gBAAU,KAAK,GAAG;AAAA,IACnB;AACA,UAAM,OAAO,UAAU,IAAI,UAAU,YAAY,SAAS;AAC1D,UAAM,UAAU,UAAU;AAC1B,UAAM,QAAQ,KAAK;AACnB,UAAM,OAAO,MAAM,GAAG;AAEtB,QAAI,WAAW,CAAC,MAAM;AACrB,aAAO;AAAA,IACR;AAEA,UAAM,UAAU;AAAA,MACf;AAAA,MACA;AAAA,MACA,QAAQ;AAAA,MACR;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACD;AACA,QAAI,YAAY,MAAM;AACrB,aAAO;AAAA,IACR;AAEA,QAAI,WAAW,KAAK;AACpB,QAAI,CAAC,MAAM;AACV;AAAA,IACD,WAAW,CAAC,SAAS;AACpB;AACA,UAAI,WAAW,yBAAyB;AACvC,eAAO,UAAU,SAAS,OAAO,UAAU,GAAG;AAAA,MAC/C;AAAA,IACD;AAEA,UAAM,aAAa,WAAW,YAAY,KAAK;AAC/C,UAAM,WAAW,MAAM,OAAO,KAAK,SAAU,UAAU;AAEvD,QAAI,YAAY;AACf,WAAK,QAAQ;AACb,WAAK,QAAQ;AACb,aAAO;AAAA,IACR;AAEA,WAAO,IAAI,iBAAiB,SAAS,UAAU,QAAQ;AAAA,EACxD;AACD;AAEA,MAAM,kBAAwB;AAAA,EAC7B,YACQ,SACA,SACA,SACN;AAHM;AACA;AACA;AAAA,EACL;AAAA,EAEH,IAAI,OAAe,SAAiB,KAAQ,aAAiB;AAC5D,UAAM,UAAU,KAAK;AACrB,aAAS,KAAK,GAAG,MAAM,QAAQ,QAAQ,KAAK,KAAK,MAAM;AACtD,UAAI,GAAG,KAAK,QAAQ,EAAE,EAAE,CAAC,CAAC,GAAG;AAC5B,eAAO,QAAQ,EAAE,EAAE,CAAC;AAAA,MACrB;AAAA,IACD;AACA,WAAO;AAAA,EACR;AAAA,EAEA,OACC,SACA,OACA,SACA,KACA,OACA,eACA,UACgB;AAChB,QAAI,YAAY,QAAW;AAC1B,gBAAU,KAAK,GAAG;AAAA,IACnB;AAEA,UAAM,UAAU,UAAU;AAE1B,QAAI,YAAY,KAAK,SAAS;AAC7B,UAAI,SAAS;AACZ,eAAO;AAAA,MACR;AACA,aAAO,QAAQ;AACf,aAAO,aAAa;AACpB,aAAO,cAAc,MAAM,SAAS,OAAO,SAAS,CAAC,KAAK,KAAK,CAAC;AAAA,IACjE;AAEA,UAAM,UAAU,KAAK;AACrB,QAAI,MAAM;AACV,UAAM,MAAM,QAAQ;AACpB,WAAO,MAAM,KAAK,OAAO;AACxB,UAAI,GAAG,KAAK,QAAQ,GAAG,EAAE,CAAC,CAAC,GAAG;AAC7B;AAAA,MACD;AAAA,IACD;AACA,UAAM,SAAS,MAAM;AAErB,QAAI,SAAS,QAAQ,GAAG,EAAE,CAAC,MAAM,QAAQ,SAAS;AACjD,aAAO;AAAA,IACR;AAEA,WAAO,QAAQ;AAEd,KAAC,WAAW,CAAC,WAAW,OAAO,aAAa;AAE7C,QAAI,WAAW,QAAQ,GAAG;AACzB,aAAO,IAAI,UAAU,SAAS,KAAK,SAAS,QAAQ,MAAM,CAAC,CAAC;AAAA,IAC7D;AAEA,UAAM,aAAa,WAAW,YAAY,KAAK;AAC/C,UAAM,aAAa,aAAa,UAAU,QAAQ,OAAO;AAEzD,QAAI,QAAQ;AACX,UAAI,SAAS;AAEZ,gBAAQ,MAAM,IAAI,WAAW,IAAI,IAAK,WAAW,GAAG,IAAI,WAAW,IAAI;AAAA,MACxE,OAAO;AACN,mBAAW,GAAG,IAAI,CAAC,KAAK,KAAK;AAAA,MAC9B;AAAA,IACD,OAAO;AACN,iBAAW,KAAK,CAAC,KAAK,KAAK,CAAC;AAAA,IAC7B;AAEA,QAAI,YAAY;AACf,WAAK,UAAU;AACf,aAAO;AAAA,IACR;AAEA,WAAO,IAAI,kBAAkB,SAAS,KAAK,SAAS,UAAU;AAAA,EAC/D;AACD;AAEA,MAAM,UAAgB;AAAA,EACrB,YACQ,SACA,SACA,OACN;AAHM;AACA;AACA;AAAA,EACL;AAAA,EAEH,IAAI,OAAe,SAAiB,KAAQ,aAAiB;AAC5D,WAAO,GAAG,KAAK,KAAK,MAAM,CAAC,CAAC,IAAI,KAAK,MAAM,CAAC,IAAI;AAAA,EACjD;AAAA,EAEA,OACC,SACA,OACA,SACA,KACA,OACA,eACA,UACC;AACD,UAAM,UAAU,UAAU;AAC1B,UAAM,WAAW,GAAG,KAAK,KAAK,MAAM,CAAC,CAAC;AACtC,QAAI,WAAW,UAAU,KAAK,MAAM,CAAC,IAAI,SAAS;AACjD,aAAO;AAAA,IACR;AAEA,WAAO,QAAQ;AAEf,QAAI,SAAS;AACZ,aAAO,aAAa;AACpB;AAAA,IACD;AAEA,QAAI,UAAU;AACb,UAAI,WAAW,YAAY,KAAK,SAAS;AACxC,aAAK,MAAM,CAAC,IAAI;AAChB,eAAO;AAAA,MACR;AACA,aAAO,IAAI,UAAU,SAAS,KAAK,SAAS,CAAC,KAAK,KAAK,CAAC;AAAA,IACzD;AAEA,WAAO,aAAa;AACpB,WAAO,cAAc,MAAM,SAAS,OAAO,KAAK,GAAG,GAAG,CAAC,KAAK,KAAK,CAAC;AAAA,EACnE;AACD;AAIA,MAAM,YAA0D;AAAA,EAG/D,YACC,KACO,OACA,UACN;AAFM;AACA;AAEP,SAAK,SAAS,IAAI,SAAS,iBAAuB,IAAI,KAAK;AAAA,EAC5D;AAAA,EARA;AAAA,EAUA,CAAC,OAAO,QAAQ,IAAmB;AAClC,WAAO;AAAA,EACR;AAAA,EAEA,OAAO;AACN,UAAM,OAAO,KAAK;AAClB,QAAI,QAAQ,KAAK;AACjB,WAAO,OAAO;AACb,YAAM,OAAO,MAAM;AACnB,YAAM,QAAQ,MAAM;AACpB,UAAI;AACJ,UAAI,KAAK,OAAO;AACf,YAAI,UAAU,GAAG;AAChB,iBAAO,iBAAiB,MAAM,KAAK,KAAK;AAAA,QACzC;AAAA,MACD,WAAW,aAAa,QAAQ,KAAK,SAAS;AAC7C,mBAAW,KAAK,QAAQ,SAAS;AACjC,YAAI,SAAS,UAAU;AACtB,iBAAO,iBAAiB,MAAM,KAAK,QAAQ,KAAK,WAAW,WAAW,QAAQ,KAAK,CAAC;AAAA,QACrF;AAAA,MACD,OAAO;AACN,mBAAW,KAAK,MAAM,SAAS;AAC/B,YAAI,SAAS,UAAU;AACtB,gBAAM,UAAU,KAAK,MAAM,KAAK,WAAW,WAAW,QAAQ,KAAK;AACnE,cAAI,SAAS;AACZ,gBAAI,QAAQ,OAAO;AAClB,qBAAO,iBAAiB,MAAM,QAAQ,KAAK;AAAA,YAC5C;AACA,oBAAQ,KAAK,SAAS,iBAAiB,SAAS,KAAK;AAAA,UACtD;AACA;AAAA,QACD;AAAA,MACD;AACA,cAAQ,KAAK,SAAS,KAAK,OAAO;AAAA,IACnC;AACA,WAAO,aAAa;AAAA,EACrB;AACD;AAEA,SAAS,iBAAuB,MAAqB,OAAe;AACnE,SAAO,cAAc,MAAM,MAAM,CAAC,GAAG,MAAM,CAAC,CAAC;AAC9C;AAQA,SAAS,iBACR,MACA,MACS;AACT,SAAO;AAAA,IACN;AAAA,IACA,OAAO;AAAA,IACP,QAAQ;AAAA,EACT;AACD;AAEA,MAAM,eAAe;AACrB,MAAM,iBAAiB;AACvB,MAAM,kBAAkB;AAIxB,SAAS,cACR,MACA,GACA,GACA,gBACC;AACD,QAAM,QAAQ,SAAS,eAAe,IAAI,SAAS,iBAAiB,IAAI,CAAC,GAAG,CAAC;AAE7E,mBACI,eAAe,QAAQ,QACvB,iBAAiB;AAAA,IAClB;AAAA,IACA,MAAM;AAAA,EACP;AACF,SAAO;AACR;AAeO,SAAS,eAAe;AAC9B,SAAO,EAAE,OAAO,QAAW,MAAM,KAAK;AACvC;AAEA,SAAS,QAAc,MAAc,MAAsB,SAAmBD,OAAe;AAC5F,QAAM,MAAM,OAAO,OAAO,aAAa,SAAS;AAChD,MAAI,OAAO;AACX,MAAI,QAAQ;AACZ,MAAI,YAAY;AAChB,MAAI,SAASA;AACb,MAAI,YAAY;AAChB,SAAO;AACR;AAEA,IAAI;AAoBG,SAAS,WAAqC;AACpD,SAAQ,cAAsB,YAAY,QAAQ,CAAC;AACpD;AAEA,SAAS,UAAgB,KAAyB,GAAM,GAAM;AAC7D,MAAI;AACJ,MAAI;AACJ,MAAI,CAAC,IAAI,OAAO;AACf,QAAI,MAAM,SAAS;AAClB,aAAO;AAAA,IACR;AACA,cAAU;AACV,cAAU,IAAI,aAAa,IAAI,WAAW,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;AAAA,EACnD,OAAO;AACN,UAAM,gBAAgB,QAAQ;AAC9B,UAAM,WAAW,QAAQ;AACzB,cAAU,WAAW,IAAI,OAAO,IAAI,WAAW,GAAG,QAAW,GAAG,GAAG,eAAe,QAAQ;AAC1F,QAAI,CAAC,SAAS,OAAO;AACpB,aAAO;AAAA,IACR;AACA,cAAU,IAAI,QAAQ,cAAc,QAAS,MAAM,UAAU,KAAK,IAAK;AAAA,EACxE;AACA,MAAI,IAAI,WAAW;AAClB,QAAI,OAAO;AACX,QAAI,QAAQ;AACZ,QAAI,SAAS;AACb,QAAI,YAAY;AAChB,WAAO;AAAA,EACR;AACA,SAAO,UAAU,QAAQ,SAAS,OAAO,IAAI,SAAS;AACvD;AAEA,SAAS,WACR,MACA,SACA,OACA,SACA,KACA,OACA,eACA,UAC4B;AAC5B,MAAI,CAAC,MAAM;AACV,QAAI,UAAU,SAAS;AACtB,aAAO;AAAA,IACR;AACA,WAAO,QAAQ;AACf,WAAO,aAAa;AACpB,WAAO,IAAI,UAAU,SAAS,SAAS,CAAC,KAAK,KAAK,CAAC;AAAA,EACpD;AACA,SAAO,KAAK,OAAO,SAAS,OAAO,SAAU,KAAK,OAAO,eAAe,QAAQ;AACjF;AAEA,SAAS,WAAW,MAAiC;AACpD,SAAO,KAAK,gBAAgB,aAAa,KAAK,gBAAgB;AAC/D;AAEA,SAAS,cACR,MACA,SACA,OACA,SACA,OACgB;AAChB,MAAI,KAAK,YAAY,SAAS;AAC7B,WAAO,IAAI,kBAAkB,SAAS,SAAS,CAAC,KAAK,OAAO,KAAK,CAAC;AAAA,EACnE;AAEA,QAAM,QAAQ,UAAU,IAAI,KAAK,UAAU,KAAK,YAAY,SAAS;AACrE,QAAM,QAAQ,UAAU,IAAI,UAAU,YAAY,SAAS;AAE3D,MAAI;AACJ,QAAM,QACL,SAAS,OACN,CAAC,cAAc,MAAM,SAAS,QAAQ,OAAO,SAAS,KAAK,CAAC,KAC1D,UAAU,IAAI,UAAU,SAAS,SAAS,KAAK,GAClD,OAAO,OAAO,CAAC,MAAM,OAAO,IAAI,CAAC,SAAS,IAAI;AAEjD,SAAO,IAAI,kBAAkB,SAAU,KAAK,OAAS,KAAK,MAAO,KAAK;AACvE;AAEA,SAAS,YAAkB,SAAkB,SAAmB,KAAQ,OAAU;AACjF,MAAI,CAAC,SAAS;AACb,cAAU,IAAI,QAAQ;AAAA,EACvB;AACA,MAAI,OAAsB,IAAI,UAAU,SAAS,KAAK,GAAG,GAAG,CAAC,KAAK,KAAK,CAAC;AACxE,WAAS,KAAK,GAAG,KAAK,QAAQ,QAAQ,MAAM;AAC3C,UAAM,QAAQ,QAAQ,EAAE;AACxB,WAAO,KAAK,OAAO,SAAS,GAAG,QAA4B,MAAM,CAAC,GAAG,MAAM,CAAC,CAAC;AAAA,EAC9E;AACA,SAAO;AACR;AAEA,SAAS,UACR,SACA,OACA,OACA,WACC;AACD,MAAI,SAAS;AACb,MAAI,WAAW;AACf,QAAM,cAAc,IAAI,MAAM,KAAK;AACnC,WAAS,KAAK,GAAG,MAAM,GAAG,MAAM,MAAM,QAAQ,KAAK,KAAK,MAAM,QAAQ,GAAG;AACxE,UAAM,OAAO,MAAM,EAAE;AACrB,QAAI,SAAS,UAAa,OAAO,WAAW;AAC3C,gBAAU;AACV,kBAAY,UAAU,IAAI;AAAA,IAC3B;AAAA,EACD;AACA,SAAO,IAAI,kBAAkB,SAAS,QAAQ,WAAW;AAC1D;AAEA,SAAS,YACR,SACA,OACA,QACA,WACA,MACgB;AAChB,MAAI,QAAQ;AACZ,QAAM,gBAAgB,IAAI,MAAM,IAAI;AACpC,WAAS,KAAK,GAAG,WAAW,GAAG,MAAM,YAAY,GAAG;AACnD,kBAAc,EAAE,IAAI,SAAS,IAAI,MAAM,OAAO,IAAI;AAAA,EACnD;AACA,gBAAc,SAAS,IAAI;AAC3B,SAAO,IAAI,iBAAiB,SAAS,QAAQ,GAAG,aAAa;AAC9D;AAEA,SAAS,SAAS,GAAW;AAC5B,OAAM,KAAK,IAAK;AAChB,OAAK,IAAI,cAAgB,KAAK,IAAK;AACnC,MAAK,KAAK,KAAK,KAAM;AACrB,OAAK,KAAK;AACV,OAAK,KAAK;AACV,SAAO,IAAI;AACZ;AAEA,SAAS,MAAS,OAAY,KAAa,KAAQ,SAAuB;AACzE,QAAM,WAAW,UAAU,QAAQ,QAAQ,KAAK;AAChD,WAAS,GAAG,IAAI;AAChB,SAAO;AACR;AAEA,SAAS,SAAY,OAAY,KAAa,KAAQ,SAAuB;AAC5E,QAAM,SAAS,MAAM,SAAS;AAC9B,MAAI,WAAW,MAAM,MAAM,QAAQ;AAClC,UAAM,GAAG,IAAI;AACb,WAAO;AAAA,EACR;AACA,QAAM,WAAW,IAAI,MAAS,MAAM;AACpC,MAAI,QAAQ;AACZ,WAAS,KAAK,GAAG,KAAK,QAAQ,MAAM;AACnC,QAAI,OAAO,KAAK;AACf,eAAS,EAAE,IAAI;AACf,cAAQ;AAAA,IACT,OAAO;AACN,eAAS,EAAE,IAAI,MAAM,KAAK,KAAK;AAAA,IAChC;AAAA,EACD;AACA,SAAO;AACR;AAEA,SAAS,UAAa,OAAY,KAAa,SAAkB;AAChE,QAAM,SAAS,MAAM,SAAS;AAC9B,MAAI,WAAW,QAAQ,QAAQ;AAC9B,UAAM,IAAI;AACV,WAAO;AAAA,EACR;AACA,QAAM,WAAW,IAAI,MAAM,MAAM;AACjC,MAAI,QAAQ;AACZ,WAAS,KAAK,GAAG,KAAK,QAAQ,MAAM;AACnC,QAAI,OAAO,KAAK;AACf,cAAQ;AAAA,IACT;AACA,aAAS,EAAE,IAAI,MAAM,KAAK,KAAK;AAAA,EAChC;AACA,SAAO;AACR;AAEA,MAAM,qBAAqB,OAAO;AAClC,MAAM,0BAA0B,OAAO;AACvC,MAAM,0BAA0B,OAAO;",
  "names": ["hash", "nextHash"]
}
