{
  "version": 3,
  "sources": ["../../src/lib/StoreQueries.ts"],
  "sourcesContent": ["import {\n\tAtom,\n\tcomputed,\n\tComputed,\n\tEMPTY_ARRAY,\n\tisUninitialized,\n\tRESET_VALUE,\n\twithDiff,\n} from '@tldraw/state'\nimport { areArraysShallowEqual, isEqual, objectMapValues } from '@tldraw/utils'\nimport { AtomMap } from './AtomMap'\nimport { IdOf, UnknownRecord } from './BaseRecord'\nimport { executeQuery, objectMatchesQuery, QueryExpression } from './executeQuery'\nimport { IncrementalSetConstructor } from './IncrementalSetConstructor'\nimport { RecordsDiff } from './RecordsDiff'\nimport { diffSets } from './setUtils'\nimport { CollectionDiff } from './Store'\n\n/**\n * A type representing the diff of changes to a reactive store index.\n * Maps property values to the collection differences for record IDs that have that property value.\n *\n * @example\n * ```ts\n * // For an index on book titles, the diff might look like:\n * const titleIndexDiff: RSIndexDiff<Book, 'title'> = new Map([\n *   ['The Lathe of Heaven', { added: new Set(['book:1']), removed: new Set() }],\n *   ['Animal Farm', { added: new Set(), removed: new Set(['book:2']) }]\n * ])\n * ```\n *\n * @public\n */\nexport type RSIndexDiff<R extends UnknownRecord> = Map<any, CollectionDiff<IdOf<R>>>\n\n/**\n * A type representing a reactive store index as a map from property values to sets of record IDs.\n * This is used to efficiently look up records by a specific property value.\n *\n * @example\n * ```ts\n * // Index mapping book titles to the IDs of books with that title\n * const titleIndex: RSIndexMap<Book, 'title'> = new Map([\n *   ['The Lathe of Heaven', new Set(['book:1'])],\n *   ['Animal Farm', new Set(['book:2', 'book:3'])]\n * ])\n * ```\n *\n * @public\n */\nexport type RSIndexMap<R extends UnknownRecord> = Map<any, Set<IdOf<R>>>\n\n/**\n * A reactive computed index that provides efficient lookups of records by property values.\n * Returns a computed value containing an RSIndexMap with diffs for change tracking.\n *\n * @example\n * ```ts\n * // Create an index on book authors\n * const authorIndex: RSIndex<Book, 'authorId'> = store.query.index('book', 'authorId')\n *\n * // Get all books by a specific author\n * const leguinBooks = authorIndex.get().get('author:leguin')\n * ```\n *\n * @public\n */\nexport type RSIndex<R extends UnknownRecord> = Computed<RSIndexMap<R>, RSIndexDiff<R>>\n\n/**\n * A class that provides reactive querying capabilities for a record store.\n * Offers methods to create indexes, filter records, and perform efficient lookups with automatic cache management.\n * All queries are reactive and will automatically update when the underlying store data changes.\n *\n * @example\n * ```ts\n * // Create a store with books\n * const store = new Store({ schema: StoreSchema.create({ book: Book, author: Author }) })\n *\n * // Get reactive queries for books\n * const booksByAuthor = store.query.index('book', 'authorId')\n * const inStockBooks = store.query.records('book', () => ({ inStock: { eq: true } }))\n * ```\n *\n * @public\n */\nexport class StoreQueries<R extends UnknownRecord> {\n\t/**\n\t * Creates a new StoreQueries instance.\n\t *\n\t * recordMap - The atom map containing all records in the store\n\t * history - The atom tracking the store's change history with diffs\n\t *\n\t * @internal\n\t */\n\tconstructor(\n\t\tprivate readonly recordMap: AtomMap<IdOf<R>, R>,\n\t\tprivate readonly history: Atom<number, RecordsDiff<R>>\n\t) {}\n\n\t/**\n\t * A cache of derivations (indexes).\n\t *\n\t * @internal\n\t */\n\tprivate indexCache = new Map<string, RSIndex<R>>()\n\n\t/**\n\t * A cache of derivations (filtered histories).\n\t *\n\t * @internal\n\t */\n\tprivate historyCache = new Map<string, Computed<number, RecordsDiff<R>>>()\n\n\t/**\n\t * @internal\n\t */\n\tpublic getAllIdsForType<TypeName extends R['typeName']>(\n\t\ttypeName: TypeName\n\t): Set<IdOf<Extract<R, { typeName: TypeName }>>> {\n\t\ttype S = Extract<R, { typeName: TypeName }>\n\t\tconst ids = new Set<IdOf<S>>()\n\t\tfor (const record of this.recordMap.values()) {\n\t\t\tif (record.typeName === typeName) {\n\t\t\t\tids.add(record.id as IdOf<S>)\n\t\t\t}\n\t\t}\n\t\treturn ids\n\t}\n\n\t/**\n\t * @internal\n\t */\n\tpublic getRecordById<TypeName extends R['typeName']>(\n\t\ttypeName: TypeName,\n\t\tid: IdOf<Extract<R, { typeName: TypeName }>>\n\t): Extract<R, { typeName: TypeName }> | undefined {\n\t\tconst record = this.recordMap.get(id as IdOf<R>)\n\t\tif (record && record.typeName === typeName) {\n\t\t\treturn record as Extract<R, { typeName: TypeName }>\n\t\t}\n\t\treturn undefined\n\t}\n\n\t/**\n\t * Helper to extract nested property value using pre-split path parts.\n\t * @internal\n\t */\n\tprivate getNestedValue(obj: any, pathParts: string[]): any {\n\t\tlet current = obj\n\t\tfor (const part of pathParts) {\n\t\t\tif (current == null || typeof current !== 'object') return undefined\n\t\t\tcurrent = current[part]\n\t\t}\n\t\treturn current\n\t}\n\n\t/**\n\t * Creates a reactive computed that tracks the change history for records of a specific type.\n\t * The returned computed provides incremental diffs showing what records of the given type\n\t * have been added, updated, or removed.\n\t *\n\t * @param typeName - The type name to filter the history by\n\t * @returns A computed value containing the current epoch and diffs of changes for the specified type\n\t *\n\t * @example\n\t * ```ts\n\t * // Track changes to book records only\n\t * const bookHistory = store.query.filterHistory('book')\n\t *\n\t * // React to book changes\n\t * react('book-changes', () => {\n\t *   const currentEpoch = bookHistory.get()\n\t *   console.log('Books updated at epoch:', currentEpoch)\n\t * })\n\t * ```\n\t *\n\t * @public\n\t */\n\tpublic filterHistory<TypeName extends R['typeName']>(\n\t\ttypeName: TypeName\n\t): Computed<number, RecordsDiff<Extract<R, { typeName: TypeName }>>> {\n\t\ttype S = Extract<R, { typeName: TypeName }>\n\n\t\tif (this.historyCache.has(typeName)) {\n\t\t\treturn this.historyCache.get(typeName) as any\n\t\t}\n\n\t\tconst filtered = computed<number, RecordsDiff<S>>(\n\t\t\t'filterHistory:' + typeName,\n\t\t\t(lastValue, lastComputedEpoch) => {\n\t\t\t\tif (isUninitialized(lastValue)) {\n\t\t\t\t\treturn this.history.get()\n\t\t\t\t}\n\n\t\t\t\tconst diff = this.history.getDiffSince(lastComputedEpoch)\n\t\t\t\tif (diff === RESET_VALUE) return this.history.get()\n\n\t\t\t\tconst res = { added: {}, removed: {}, updated: {} } as RecordsDiff<S>\n\t\t\t\tlet numAdded = 0\n\t\t\t\tlet numRemoved = 0\n\t\t\t\tlet numUpdated = 0\n\n\t\t\t\tfor (const changes of diff) {\n\t\t\t\t\tfor (const added of objectMapValues(changes.added)) {\n\t\t\t\t\t\tif (added.typeName === typeName) {\n\t\t\t\t\t\t\tif (res.removed[added.id as IdOf<S>]) {\n\t\t\t\t\t\t\t\tconst original = res.removed[added.id as IdOf<S>]\n\t\t\t\t\t\t\t\tdelete res.removed[added.id as IdOf<S>]\n\t\t\t\t\t\t\t\tnumRemoved--\n\t\t\t\t\t\t\t\tif (original !== added) {\n\t\t\t\t\t\t\t\t\tres.updated[added.id as IdOf<S>] = [original, added as S]\n\t\t\t\t\t\t\t\t\tnumUpdated++\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tres.added[added.id as IdOf<S>] = added as S\n\t\t\t\t\t\t\t\tnumAdded++\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (const [from, to] of objectMapValues(changes.updated)) {\n\t\t\t\t\t\tif (to.typeName === typeName) {\n\t\t\t\t\t\t\tif (res.added[to.id as IdOf<S>]) {\n\t\t\t\t\t\t\t\tres.added[to.id as IdOf<S>] = to as S\n\t\t\t\t\t\t\t} else if (res.updated[to.id as IdOf<S>]) {\n\t\t\t\t\t\t\t\tres.updated[to.id as IdOf<S>] = [res.updated[to.id as IdOf<S>][0], to as S]\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tres.updated[to.id as IdOf<S>] = [from as S, to as S]\n\t\t\t\t\t\t\t\tnumUpdated++\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (const removed of objectMapValues(changes.removed)) {\n\t\t\t\t\t\tif (removed.typeName === typeName) {\n\t\t\t\t\t\t\tif (res.added[removed.id as IdOf<S>]) {\n\t\t\t\t\t\t\t\t// was added during this diff sequence, so just undo the add\n\t\t\t\t\t\t\t\tdelete res.added[removed.id as IdOf<S>]\n\t\t\t\t\t\t\t\tnumAdded--\n\t\t\t\t\t\t\t} else if (res.updated[removed.id as IdOf<S>]) {\n\t\t\t\t\t\t\t\t// remove oldest version\n\t\t\t\t\t\t\t\tres.removed[removed.id as IdOf<S>] = res.updated[removed.id as IdOf<S>][0]\n\t\t\t\t\t\t\t\tdelete res.updated[removed.id as IdOf<S>]\n\t\t\t\t\t\t\t\tnumUpdated--\n\t\t\t\t\t\t\t\tnumRemoved++\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tres.removed[removed.id as IdOf<S>] = removed as S\n\t\t\t\t\t\t\t\tnumRemoved++\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (numAdded || numRemoved || numUpdated) {\n\t\t\t\t\treturn withDiff(this.history.get(), res)\n\t\t\t\t} else {\n\t\t\t\t\treturn lastValue\n\t\t\t\t}\n\t\t\t},\n\t\t\t{ historyLength: 100 }\n\t\t)\n\n\t\tthis.historyCache.set(typeName, filtered)\n\n\t\treturn filtered\n\t}\n\n\t/**\n\t * Creates a reactive index that maps property values to sets of record IDs for efficient lookups.\n\t * The index automatically updates when records are added, updated, or removed, and results are cached\n\t * for performance.\n\t *\n\t * Supports nested property paths using backslash separator (e.g., 'metadata\\\\sessionId').\n\t *\n\t * @param typeName - The type name of records to index\n\t * @param path - The property name or backslash-delimited path to index by\n\t * @returns A reactive computed containing the index map with change diffs\n\t *\n\t * @example\n\t * ```ts\n\t * // Create an index of books by author ID\n\t * const booksByAuthor = store.query.index('book', 'authorId')\n\t *\n\t * // Get all books by a specific author\n\t * const authorBooks = booksByAuthor.get().get('author:leguin')\n\t * console.log(authorBooks) // Set<RecordId<Book>>\n\t *\n\t * // Index by nested property using backslash separator\n\t * const booksBySession = store.query.index('book', 'metadata\\\\sessionId')\n\t * const sessionBooks = booksBySession.get().get('session:alpha')\n\t * ```\n\t *\n\t * @public\n\t */\n\tpublic index<TypeName extends R['typeName']>(\n\t\ttypeName: TypeName,\n\t\tpath: string\n\t): RSIndex<Extract<R, { typeName: TypeName }>> {\n\t\tconst cacheKey = typeName + ':' + path\n\n\t\tif (this.indexCache.has(cacheKey)) {\n\t\t\treturn this.indexCache.get(cacheKey) as any\n\t\t}\n\n\t\tconst index = this.__uncached_createIndex(typeName, path)\n\n\t\tthis.indexCache.set(cacheKey, index as any)\n\n\t\treturn index\n\t}\n\n\t/**\n\t * Creates a new index without checking the cache. This method performs the actual work\n\t * of building the reactive index computation that tracks property values to record ID sets.\n\t *\n\t * Supports nested property paths using backslash separator.\n\t *\n\t * @param typeName - The type name of records to index\n\t * @param path - The property name or backslash-delimited path to index by\n\t * @returns A reactive computed containing the index map with change diffs\n\t *\n\t * @internal\n\t */\n\t__uncached_createIndex<TypeName extends R['typeName']>(\n\t\ttypeName: TypeName,\n\t\tpath: string\n\t): RSIndex<Extract<R, { typeName: TypeName }>> {\n\t\ttype S = Extract<R, { typeName: TypeName }>\n\n\t\tconst typeHistory = this.filterHistory(typeName)\n\n\t\t// Create closure for efficient property value extraction\n\t\tconst pathParts = path.split('\\\\')\n\t\tconst getPropertyValue =\n\t\t\tpathParts.length > 1\n\t\t\t\t? (obj: S) => this.getNestedValue(obj, pathParts)\n\t\t\t\t: (obj: S) => obj[path as keyof S]\n\n\t\tconst fromScratch = () => {\n\t\t\t// deref typeHistory early so that the first time the incremental version runs\n\t\t\t// it gets a diff to work with instead of having to bail to this from-scratch version\n\t\t\ttypeHistory.get()\n\t\t\tconst res = new Map<any, Set<IdOf<S>>>()\n\t\t\tfor (const record of this.recordMap.values()) {\n\t\t\t\tif (record.typeName === typeName) {\n\t\t\t\t\tconst value = getPropertyValue(record as S)\n\t\t\t\t\tif (value !== undefined) {\n\t\t\t\t\t\tif (!res.has(value)) {\n\t\t\t\t\t\t\tres.set(value, new Set())\n\t\t\t\t\t\t}\n\t\t\t\t\t\tres.get(value)!.add(record.id)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn res\n\t\t}\n\n\t\treturn computed<RSIndexMap<S>, RSIndexDiff<S>>(\n\t\t\t'index:' + typeName + ':' + path,\n\t\t\t(prevValue, lastComputedEpoch) => {\n\t\t\t\tif (isUninitialized(prevValue)) return fromScratch()\n\n\t\t\t\tconst history = typeHistory.getDiffSince(lastComputedEpoch)\n\t\t\t\tif (history === RESET_VALUE) {\n\t\t\t\t\treturn fromScratch()\n\t\t\t\t}\n\n\t\t\t\tconst setConstructors = new Map<any, IncrementalSetConstructor<IdOf<S>>>()\n\n\t\t\t\tconst add = (value: any, id: IdOf<S>) => {\n\t\t\t\t\tlet setConstructor = setConstructors.get(value)\n\t\t\t\t\tif (!setConstructor)\n\t\t\t\t\t\tsetConstructor = new IncrementalSetConstructor<IdOf<S>>(\n\t\t\t\t\t\t\tprevValue.get(value) ?? new Set()\n\t\t\t\t\t\t)\n\t\t\t\t\tsetConstructor.add(id)\n\t\t\t\t\tsetConstructors.set(value, setConstructor)\n\t\t\t\t}\n\n\t\t\t\tconst remove = (value: any, id: IdOf<S>) => {\n\t\t\t\t\tlet set = setConstructors.get(value)\n\t\t\t\t\tif (!set) set = new IncrementalSetConstructor<IdOf<S>>(prevValue.get(value) ?? new Set())\n\t\t\t\t\tset.remove(id)\n\t\t\t\t\tsetConstructors.set(value, set)\n\t\t\t\t}\n\n\t\t\t\tfor (const changes of history) {\n\t\t\t\t\tfor (const record of objectMapValues(changes.added)) {\n\t\t\t\t\t\tif (record.typeName === typeName) {\n\t\t\t\t\t\t\tconst value = getPropertyValue(record as S)\n\t\t\t\t\t\t\tif (value !== undefined) {\n\t\t\t\t\t\t\t\tadd(value, record.id)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (const [from, to] of objectMapValues(changes.updated)) {\n\t\t\t\t\t\tif (to.typeName === typeName) {\n\t\t\t\t\t\t\tconst prev = getPropertyValue(from as S)\n\t\t\t\t\t\t\tconst next = getPropertyValue(to as S)\n\t\t\t\t\t\t\tif (prev !== next) {\n\t\t\t\t\t\t\t\tif (prev !== undefined) {\n\t\t\t\t\t\t\t\t\tremove(prev, to.id)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (next !== undefined) {\n\t\t\t\t\t\t\t\t\tadd(next, to.id)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (const record of objectMapValues(changes.removed)) {\n\t\t\t\t\t\tif (record.typeName === typeName) {\n\t\t\t\t\t\t\tconst value = getPropertyValue(record as S)\n\t\t\t\t\t\t\tif (value !== undefined) {\n\t\t\t\t\t\t\t\tremove(value, record.id)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tlet nextValue: undefined | RSIndexMap<S> = undefined\n\t\t\t\tlet nextDiff: undefined | RSIndexDiff<S> = undefined\n\n\t\t\t\tfor (const [value, setConstructor] of setConstructors) {\n\t\t\t\t\tconst result = setConstructor.get()\n\t\t\t\t\tif (!result) continue\n\t\t\t\t\tif (!nextValue) nextValue = new Map(prevValue)\n\t\t\t\t\tif (!nextDiff) nextDiff = new Map()\n\t\t\t\t\tif (result.value.size === 0) {\n\t\t\t\t\t\tnextValue.delete(value)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnextValue.set(value, result.value)\n\t\t\t\t\t}\n\t\t\t\t\tnextDiff.set(value, result.diff)\n\t\t\t\t}\n\n\t\t\t\tif (nextValue && nextDiff) {\n\t\t\t\t\treturn withDiff(nextValue, nextDiff)\n\t\t\t\t}\n\n\t\t\t\treturn prevValue\n\t\t\t},\n\t\t\t{ historyLength: 100 }\n\t\t)\n\t}\n\n\t/**\n\t * Creates a reactive query that returns the first record matching the given query criteria.\n\t * Returns undefined if no matching record is found. The query automatically updates\n\t * when records change.\n\t *\n\t * @param typeName - The type name of records to query\n\t * @param queryCreator - Function that returns the query expression object to match against\n\t * @param name - Optional name for the query computation (used for debugging)\n\t * @returns A computed value containing the first matching record or undefined\n\t *\n\t * @example\n\t * ```ts\n\t * // Find the first book with a specific title\n\t * const bookLatheOfHeaven = store.query.record('book', () => ({ title: { eq: 'The Lathe of Heaven' } }))\n\t * console.log(bookLatheOfHeaven.get()?.title) // 'The Lathe of Heaven' or undefined\n\t *\n\t * // Find any book in stock\n\t * const anyInStockBook = store.query.record('book', () => ({ inStock: { eq: true } }))\n\t * ```\n\t *\n\t * @public\n\t */\n\trecord<TypeName extends R['typeName']>(\n\t\ttypeName: TypeName,\n\t\tqueryCreator: () => QueryExpression<Extract<R, { typeName: TypeName }>> = () => ({}),\n\t\tname = 'record:' + typeName + (queryCreator ? ':' + queryCreator.toString() : '')\n\t): Computed<Extract<R, { typeName: TypeName }> | undefined> {\n\t\ttype S = Extract<R, { typeName: TypeName }>\n\t\tconst ids = this.ids(typeName, queryCreator, name)\n\n\t\treturn computed<S | undefined>(name, () => {\n\t\t\tfor (const id of ids.get()) {\n\t\t\t\treturn this.recordMap.get(id) as S | undefined\n\t\t\t}\n\t\t\treturn undefined\n\t\t})\n\t}\n\n\t/**\n\t * Creates a reactive query that returns an array of all records matching the given query criteria.\n\t * The array automatically updates when records are added, updated, or removed.\n\t *\n\t * @param typeName - The type name of records to query\n\t * @param queryCreator - Function that returns the query expression object to match against\n\t * @param name - Optional name for the query computation (used for debugging)\n\t * @returns A computed value containing an array of all matching records\n\t *\n\t * @example\n\t * ```ts\n\t * // Get all books in stock\n\t * const inStockBooks = store.query.records('book', () => ({ inStock: { eq: true } }))\n\t * console.log(inStockBooks.get()) // Book[]\n\t *\n\t * // Get all books by a specific author\n\t * const leguinBooks = store.query.records('book', () => ({ authorId: { eq: 'author:leguin' } }))\n\t *\n\t * // Get all books (no filter)\n\t * const allBooks = store.query.records('book')\n\t * ```\n\t *\n\t * @public\n\t */\n\trecords<TypeName extends R['typeName']>(\n\t\ttypeName: TypeName,\n\t\tqueryCreator: () => QueryExpression<Extract<R, { typeName: TypeName }>> = () => ({}),\n\t\tname = 'records:' + typeName + (queryCreator ? ':' + queryCreator.toString() : '')\n\t): Computed<Array<Extract<R, { typeName: TypeName }>>> {\n\t\ttype S = Extract<R, { typeName: TypeName }>\n\t\tconst ids = this.ids(typeName, queryCreator, 'ids:' + name)\n\n\t\treturn computed<S[]>(\n\t\t\tname,\n\t\t\t() => {\n\t\t\t\treturn Array.from(ids.get(), (id) => this.recordMap.get(id) as S)\n\t\t\t},\n\t\t\t{\n\t\t\t\tisEqual: areArraysShallowEqual,\n\t\t\t}\n\t\t)\n\t}\n\n\t/**\n\t * Creates a reactive query that returns a set of record IDs matching the given query criteria.\n\t * This is more efficient than `records()` when you only need the IDs and not the full record objects.\n\t * The set automatically updates with collection diffs when records change.\n\t *\n\t * @param typeName - The type name of records to query\n\t * @param queryCreator - Function that returns the query expression object to match against\n\t * @param name - Optional name for the query computation (used for debugging)\n\t * @returns A computed value containing a set of matching record IDs with collection diffs\n\t *\n\t * @example\n\t * ```ts\n\t * // Get IDs of all books in stock\n\t * const inStockBookIds = store.query.ids('book', () => ({ inStock: { eq: true } }))\n\t * console.log(inStockBookIds.get()) // Set<RecordId<Book>>\n\t *\n\t * // Get all book IDs (no filter)\n\t * const allBookIds = store.query.ids('book')\n\t *\n\t * // Use with other queries for efficient lookups\n\t * const authorBookIds = store.query.ids('book', () => ({ authorId: { eq: 'author:leguin' } }))\n\t * ```\n\t *\n\t * @public\n\t */\n\tids<TypeName extends R['typeName']>(\n\t\ttypeName: TypeName,\n\t\tqueryCreator: () => QueryExpression<Extract<R, { typeName: TypeName }>> = () => ({}),\n\t\tname = 'ids:' + typeName + (queryCreator ? ':' + queryCreator.toString() : '')\n\t): Computed<\n\t\tSet<IdOf<Extract<R, { typeName: TypeName }>>>,\n\t\tCollectionDiff<IdOf<Extract<R, { typeName: TypeName }>>>\n\t> {\n\t\ttype S = Extract<R, { typeName: TypeName }>\n\n\t\tconst typeHistory = this.filterHistory(typeName)\n\n\t\tconst fromScratch = () => {\n\t\t\t// deref type history early to allow first incremental update to use diffs\n\t\t\ttypeHistory.get()\n\t\t\tconst query: QueryExpression<S> = queryCreator()\n\t\t\tif (Object.keys(query).length === 0) {\n\t\t\t\treturn this.getAllIdsForType(typeName)\n\t\t\t}\n\n\t\t\treturn executeQuery(this, typeName, query)\n\t\t}\n\n\t\tconst fromScratchWithDiff = (prevValue: Set<IdOf<S>>) => {\n\t\t\tconst nextValue = fromScratch()\n\t\t\tconst diff = diffSets(prevValue, nextValue)\n\t\t\tif (diff) {\n\t\t\t\treturn withDiff(nextValue, diff)\n\t\t\t} else {\n\t\t\t\treturn prevValue\n\t\t\t}\n\t\t}\n\t\tconst cachedQuery = computed('ids_query:' + name, queryCreator, {\n\t\t\tisEqual,\n\t\t})\n\n\t\treturn computed(\n\t\t\t'query:' + name,\n\t\t\t(prevValue, lastComputedEpoch) => {\n\t\t\t\tconst query = cachedQuery.get()\n\t\t\t\tif (isUninitialized(prevValue)) {\n\t\t\t\t\treturn fromScratch()\n\t\t\t\t}\n\n\t\t\t\t// if the query changed since last time this ran then we need to start again\n\t\t\t\tif (lastComputedEpoch < cachedQuery.lastChangedEpoch) {\n\t\t\t\t\treturn fromScratchWithDiff(prevValue)\n\t\t\t\t}\n\n\t\t\t\t// otherwise iterate over the changes from the store and apply them to the previous value if needed\n\t\t\t\tconst history = typeHistory.getDiffSince(lastComputedEpoch)\n\t\t\t\tif (history === RESET_VALUE) {\n\t\t\t\t\treturn fromScratchWithDiff(prevValue)\n\t\t\t\t}\n\n\t\t\t\tconst setConstructor = new IncrementalSetConstructor<IdOf<S>>(\n\t\t\t\t\tprevValue\n\t\t\t\t) as IncrementalSetConstructor<IdOf<S>>\n\n\t\t\t\tfor (const changes of history) {\n\t\t\t\t\tfor (const added of objectMapValues(changes.added)) {\n\t\t\t\t\t\tif (added.typeName === typeName && objectMatchesQuery(query, added)) {\n\t\t\t\t\t\t\tsetConstructor.add(added.id)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (const [_, updated] of objectMapValues(changes.updated)) {\n\t\t\t\t\t\tif (updated.typeName === typeName) {\n\t\t\t\t\t\t\tif (objectMatchesQuery(query, updated)) {\n\t\t\t\t\t\t\t\tsetConstructor.add(updated.id)\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tsetConstructor.remove(updated.id)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (const removed of objectMapValues(changes.removed)) {\n\t\t\t\t\t\tif (removed.typeName === typeName) {\n\t\t\t\t\t\t\tsetConstructor.remove(removed.id)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst result = setConstructor.get()\n\t\t\t\tif (!result) {\n\t\t\t\t\treturn prevValue\n\t\t\t\t}\n\n\t\t\t\treturn withDiff(result.value, result.diff)\n\t\t\t},\n\t\t\t{ historyLength: 50 }\n\t\t)\n\t}\n\n\t/**\n\t * Executes a one-time query against the current store state and returns matching records.\n\t * This is a non-reactive query that returns results immediately without creating a computed value.\n\t * Use this when you need a snapshot of data at a specific point in time.\n\t *\n\t * @param typeName - The type name of records to query\n\t * @param query - The query expression object to match against\n\t * @returns An array of records that match the query at the current moment\n\t *\n\t * @example\n\t * ```ts\n\t * // Get current in-stock books (non-reactive)\n\t * const currentInStockBooks = store.query.exec('book', { inStock: { eq: true } })\n\t * console.log(currentInStockBooks) // Book[]\n\t *\n\t * // Unlike records(), this won't update when the data changes\n\t * const staticBookList = store.query.exec('book', { authorId: { eq: 'author:leguin' } })\n\t * ```\n\t *\n\t * @public\n\t */\n\texec<TypeName extends R['typeName']>(\n\t\ttypeName: TypeName,\n\t\tquery: QueryExpression<Extract<R, { typeName: TypeName }>>\n\t): Array<Extract<R, { typeName: TypeName }>> {\n\t\tconst ids = executeQuery(this, typeName, query)\n\t\tif (ids.size === 0) {\n\t\t\treturn EMPTY_ARRAY\n\t\t}\n\t\treturn Array.from(ids, (id) => this.recordMap.get(id) as Extract<R, { typeName: TypeName }>)\n\t}\n}\n"],
  "mappings": "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",
  "names": []
}
